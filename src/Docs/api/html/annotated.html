<html>
<head>
<title>Class List - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li class="current"><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="classes.html"><span>Class&#160;Index</span></a></li>
      <li><a href="inherits.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">Class List</div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock">Here are the classes, structs, unions and interfaces with brief descriptions:</div><table>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1__ConfigOption.html">Ogre::_ConfigOption</a></td><td class="indexvalue">Packages the details of a configuration option </td></tr>
  <tr><td class="indexkey"><a class="el" href="struct__finddata__t.html">_finddata_t</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AbstractNode.html">Ogre::AbstractNode</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptCompiler_1_1AbstractTreeBuilder.html">Ogre::ScriptCompiler::AbstractTreeBuilder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AlignedMemory.html">Ogre::AlignedMemory</a></td><td class="indexvalue">Class to provide aligned memory allocate functionality </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AllocatedObject.html">Ogre::AllocatedObject&lt; Alloc &gt;</a></td><td class="indexvalue">Superclass for all objects that wish to use custom memory allocators when their new / delete operators are called </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AndroidGLContext.html">Ogre::AndroidGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AndroidGLContextDelegate.html">Ogre::AndroidGLContextDelegate</a></td><td class="indexvalue">Implements the callback mechanisms for external context calls </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AndroidGLSupport.html">Ogre::AndroidGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AndroidWindow.html">Ogre::AndroidWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AndroidWindowDelegate.html">Ogre::AndroidWindowDelegate</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Angle.html">Ogre::Angle</a></td><td class="indexvalue">Wrapper class which identifies a value as the currently default angle type, as defined by <a class="el" href="classOgre_1_1Math.html#afb791263d1e8508fc75f698a20d96b87" title="These functions used to set the assumed angle units (radians or degrees) expected when using the Angl...">Math::setAngleUnit</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimableObject.html">Ogre::AnimableObject</a></td><td class="indexvalue">Defines an interface to classes which have one or more <a class="el" href="classOgre_1_1AnimableValue.html" title="Defines an object property which is animable, i.e.">AnimableValue</a> instances to expose </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimableValue.html">Ogre::AnimableValue</a></td><td class="indexvalue">Defines an object property which is animable, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Animation.html">Ogre::Animation</a></td><td class="indexvalue">An animation sequence </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationContainer.html">Ogre::AnimationContainer</a></td><td class="indexvalue">An animation container interface, which allows generic access to sibling animations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationControllerFunction.html">Ogre::AnimationControllerFunction</a></td><td class="indexvalue">Predefined controller function for dealing with animation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationState.html">Ogre::AnimationState</a></td><td class="indexvalue">Represents the state of an animation and the weight of its influence </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationStateControllerValue.html">Ogre::AnimationStateControllerValue</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1ControllerValue.html" title="Can either be used as an input or output value.">ControllerValue</a> wrapper class for <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of its influence.">AnimationState</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationStateSet.html">Ogre::AnimationStateSet</a></td><td class="indexvalue">Class encapsulating a set of <a class="el" href="classOgre_1_1AnimationState.html" title="Represents the state of an animation and the weight of its influence.">AnimationState</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationTrack.html">Ogre::AnimationTrack</a></td><td class="indexvalue">A 'track' in an animation sequence, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Any.html">Ogre::Any</a></td><td class="indexvalue">Variant type that can hold <a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> other type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnyNumeric.html">Ogre::AnyNumeric</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1Any.html" title="Variant type that can hold Any other type.">Any</a> class which has built in arithmetic operators, but can hold only types which support operator +,-,* and / </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Archive.html">Ogre::Archive</a></td><td class="indexvalue">Archive-handling class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ArchiveFactory.html">Ogre::ArchiveFactory</a></td><td class="indexvalue">Abstract factory class, archive codec plugins can register concrete subclasses of this </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ArchiveManager.html">Ogre::ArchiveManager</a></td><td class="indexvalue">This class manages the available <a class="el" href="classOgre_1_1ArchiveFactory.html" title="Abstract factory class, archive codec plugins can register concrete subclasses of this...">ArchiveFactory</a> plugins </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AtomAbstractNode.html">Ogre::AtomAbstractNode</a></td><td class="indexvalue">This is an abstract node which cannot be broken down further </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AtomicObject.html">Ogre::AtomicObject&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AtomicScalar.html">Ogre::AtomicScalar&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UserObjectBindings_1_1Attributes.html">Ogre::UserObjectBindings::Attributes</a></td><td class="indexvalue">Internal class that uses as data storage container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuProgramParameters_1_1AutoConstantDefinition.html">Ogre::GpuProgramParameters::AutoConstantDefinition</a></td><td class="indexvalue">Structure defining an auto constant that's available for use in a parameters object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramParameters_1_1AutoConstantEntry.html">Ogre::GpuProgramParameters::AutoConstantEntry</a></td><td class="indexvalue">Structure recording the use of an automatic parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AutoParamDataSource.html">Ogre::AutoParamDataSource</a></td><td class="indexvalue">This utility class is used to hold the information used to generate the matrices and other information required to automatically populate <a class="el" href="classOgre_1_1GpuProgramParameters.html" title="Collects together the program parameters used for a GpuProgram.">GpuProgramParameters</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AxisAlignedBox.html">Ogre::AxisAlignedBox</a></td><td class="indexvalue">A 3D box aligned with the x/y/z axes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html">Ogre::AxisAlignedBoxSceneQuery</a></td><td class="indexvalue">Specialises the <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> class for querying within an axis aligned box </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1BackgroundProcessResult.html">Ogre::BackgroundProcessResult</a></td><td class="indexvalue">Encapsulates the result of a background queue request </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BaseInstanceBatchVTF.html">Ogre::BaseInstanceBatchVTF</a></td><td class="indexvalue">Instancing implementation using vertex texture through Vertex <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Fetch (VTF) This implementation has the following advantages: Supports huge amount of instances per batch Supports skinning even with huge ammounts of instances per batch Doesn't need shader constants registers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1BatchInstance.html">Ogre::InstancedGeometry::BatchInstance</a></td><td class="indexvalue">The details of a topological <a class="el" href="classOgre_1_1InstancedGeometry_1_1BatchInstance.html" title="The details of a topological BatchInstance which is the highest level of partitioning for this class...">BatchInstance</a> which is the highest level of partitioning for this class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1InstanceManager_1_1BatchSettings.html">Ogre::InstanceManager::BatchSettings</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Billboard.html">Ogre::Billboard</a></td><td class="indexvalue">A billboard is a primitive which always faces the camera in every frame </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardChain.html">Ogre::BillboardChain</a></td><td class="indexvalue">Allows the rendering of a chain of connected billboards </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardChainFactory.html">Ogre::BillboardChainFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer.html">Ogre::BillboardParticleRenderer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1ParticleSystemRenderer.html" title="Abstract class defining the interface required to be implemented by classes which provide rendering c...">ParticleSystemRenderer</a> to render particles using a <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with the same (default...">BillboardSet</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRendererFactory.html">Ogre::BillboardParticleRendererFactory</a></td><td class="indexvalue">Factory class for <a class="el" href="classOgre_1_1BillboardParticleRenderer.html" title="Specialisation of ParticleSystemRenderer to render particles using a BillboardSet.">BillboardParticleRenderer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardSet.html">Ogre::BillboardSet</a></td><td class="indexvalue">A collection of billboards (faces which are always facing the given direction) with the same (default) dimensions, material and which are fairly close proximity to each other </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardSetFactory.html">Ogre::BillboardSetFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1BillboardSet.html" title="A collection of billboards (faces which are always facing the given direction) with the same (default...">BillboardSet</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BitArray.html">Ogre::BitArray</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Bitwise.html">Ogre::Bitwise</a></td><td class="indexvalue">Class for manipulating bit patterns </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Bone.html">Ogre::Bone</a></td><td class="indexvalue">A bone in a skeleton </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement.html">Ogre::BorderPanelOverlayElement</a></td><td class="indexvalue">A specialisation of the <a class="el" href="classOgre_1_1PanelOverlayElement.html" title="OverlayElement representing a flat, single-material (or transparent) panel which can contain other el...">PanelOverlayElement</a> to provide a panel with a border </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElementFactory.html">Ogre::BorderPanelOverlayElementFactory</a></td><td class="indexvalue">Factory for creating <a class="el" href="classOgre_1_1BorderPanelOverlayElement.html" title="A specialisation of the PanelOverlayElement to provide a panel with a border.">BorderPanelOverlayElement</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderRenderable.html">Ogre::BorderRenderable</a></td><td class="indexvalue">Class for rendering the border of a <a class="el" href="classOgre_1_1BorderPanelOverlayElement.html" title="A specialisation of the PanelOverlayElement to provide a panel with a border.">BorderPanelOverlayElement</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Box.html">Ogre::Box</a></td><td class="indexvalue">Structure used to define a box in a 3-D integer space </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9HardwareIndexBuffer_1_1BufferResources.html">Ogre::D3D9HardwareIndexBuffer::BufferResources</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9HardwarePixelBuffer_1_1BufferResources.html">Ogre::D3D9HardwarePixelBuffer::BufferResources</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9HardwareVertexBuffer_1_1BufferResources.html">Ogre::D3D9HardwareVertexBuffer::BufferResources</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BuiltinScriptTranslatorManager.html">Ogre::BuiltinScriptTranslatorManager</a></td><td class="indexvalue">This class manages the builtin translators </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Camera.html">Ogre::Camera</a></td><td class="indexvalue">A viewpoint from which the scene will be rendered </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CategorisedAlignAllocPolicy.html">Ogre::CategorisedAlignAllocPolicy&lt; Cat, align &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CategorisedAllocPolicy.html">Ogre::CategorisedAllocPolicy&lt; Cat &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1BorderPanelOverlayElement_1_1CellUV.html">Ogre::BorderPanelOverlayElement::CellUV</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1CGProgramProcessor.html">Ogre::RTShader::CGProgramProcessor</a></td><td class="indexvalue">CG Language program processor class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1CGProgramWriter.html">Ogre::RTShader::CGProgramWriter</a></td><td class="indexvalue">CG target language writer implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1BillboardChain_1_1ChainSegment.html">Ogre::BillboardChain::ChainSegment</a></td><td class="indexvalue">Simple struct defining a chain segment by referencing a subset of the preallocated buffer (which will be mMaxElementsPerChain * mChainCount long), by it's chain index, and a head and tail value which describe the current chain </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1StreamSerialiser_1_1Chunk.html">Ogre::StreamSerialiser::Chunk</a></td><td class="indexvalue">Definition of a chunk of data in a file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdAccurateFacing.html">Ogre::BillboardParticleRenderer::CmdAccurateFacing</a></td><td class="indexvalue">Command object for accurate facing(see ParamCommand) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdAdjacency.html">Ogre::GpuProgram::CmdAdjacency</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdAlignment.html">Ogre::TextAreaOverlayElement::CmdAlignment</a></td><td class="indexvalue">Command object for setting the alignment </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdAngle.html">Ogre::EmitterCommands::CmdAngle</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1ParticleEmitter.html" title="Abstract class defining the interface to be implemented by particle emitters.">ParticleEmitter</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdAssemblerCode.html">Ogre::D3D9HLSLProgram::CmdAssemblerCode</a></td><td class="indexvalue">Command object for getting/setting assembler code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram_1_1CmdAttach.html">Ogre::GLSLProgram::CmdAttach</a></td><td class="indexvalue">Command object for attaching another GLSL Program </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdBillboardOrigin.html">Ogre::BillboardParticleRenderer::CmdBillboardOrigin</a></td><td class="indexvalue">Command object for billboard origin (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdBillboardRotationType.html">Ogre::BillboardParticleRenderer::CmdBillboardRotationType</a></td><td class="indexvalue">Command object for billboard rotation type (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdBillboardType.html">Ogre::BillboardParticleRenderer::CmdBillboardType</a></td><td class="indexvalue">Command object for billboard type (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderBottomLeftUV.html">Ogre::BorderPanelOverlayElement::CmdBorderBottomLeftUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderBottomRightUV.html">Ogre::BorderPanelOverlayElement::CmdBorderBottomRightUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderBottomUV.html">Ogre::BorderPanelOverlayElement::CmdBorderBottomUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderLeftUV.html">Ogre::BorderPanelOverlayElement::CmdBorderLeftUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderMaterial.html">Ogre::BorderPanelOverlayElement::CmdBorderMaterial</a></td><td class="indexvalue">Command object for specifying the <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderRightUV.html">Ogre::BorderPanelOverlayElement::CmdBorderRightUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderSize.html">Ogre::BorderPanelOverlayElement::CmdBorderSize</a></td><td class="indexvalue">Command object for specifying border sizes (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderTopLeftUV.html">Ogre::BorderPanelOverlayElement::CmdBorderTopLeftUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderTopRightUV.html">Ogre::BorderPanelOverlayElement::CmdBorderTopRightUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BorderPanelOverlayElement_1_1CmdBorderTopUV.html">Ogre::BorderPanelOverlayElement::CmdBorderTopUV</a></td><td class="indexvalue">Command object for specifying texture coordinates for the border (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdCaption.html">Ogre::OverlayElementCommands::CmdCaption</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdCaption.html">Ogre::TextAreaOverlayElement::CmdCaption</a></td><td class="indexvalue">Command object for setting the caption </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdCharHeight.html">Ogre::TextAreaOverlayElement::CmdCharHeight</a></td><td class="indexvalue">Command object for setting the char height </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdCharSpacer.html">Ogre::Font::CmdCharSpacer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdCodePoints.html">Ogre::Font::CmdCodePoints</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdColour.html">Ogre::TextAreaOverlayElement::CmdColour</a></td><td class="indexvalue">Command object for setting the constant colour </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdColour.html">Ogre::EmitterCommands::CmdColour</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdColourBottom.html">Ogre::TextAreaOverlayElement::CmdColourBottom</a></td><td class="indexvalue">Command object for setting the bottom colour </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdColourRangeEnd.html">Ogre::EmitterCommands::CmdColourRangeEnd</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdColourRangeStart.html">Ogre::EmitterCommands::CmdColourRangeStart</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdColourTop.html">Ogre::TextAreaOverlayElement::CmdColourTop</a></td><td class="indexvalue">Command object for setting the top colour </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram_1_1CmdColumnMajorMatrices.html">Ogre::D3D11HLSLProgram::CmdColumnMajorMatrices</a></td><td class="indexvalue">Command object for setting matrix packing in column-major order </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuProgram_1_1CmdColumnMajorMatrices.html">Ogre::D3D9GpuProgram::CmdColumnMajorMatrices</a></td><td class="indexvalue">Command object for setting matrix packing in column-major order </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdColumnMajorMatrices.html">Ogre::D3D9HLSLProgram::CmdColumnMajorMatrices</a></td><td class="indexvalue">Command object for setting matrix packing in column-major order </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdCommonDirection.html">Ogre::BillboardParticleRenderer::CmdCommonDirection</a></td><td class="indexvalue">Command object for common direction (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdCommonUpVector.html">Ogre::BillboardParticleRenderer::CmdCommonUpVector</a></td><td class="indexvalue">Command object for common up-vector (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdCull.html">Ogre::ParticleSystem::CmdCull</a></td><td class="indexvalue">Command object for cull_each (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UnifiedHighLevelGpuProgram_1_1CmdDelegate.html">Ogre::UnifiedHighLevelGpuProgram::CmdDelegate</a></td><td class="indexvalue">Command object for setting delegate (can set more than once) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdDirection.html">Ogre::EmitterCommands::CmdDirection</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdDuration.html">Ogre::EmitterCommands::CmdDuration</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdEmissionRate.html">Ogre::EmitterCommands::CmdEmissionRate</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdEmittedEmitter.html">Ogre::EmitterCommands::CmdEmittedEmitter</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdEmittedEmitterQuota.html">Ogre::ParticleSystem::CmdEmittedEmitterQuota</a></td><td class="indexvalue">Command object for emittedEmitterQuota (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram_1_1CmdEnableBackwardsCompatibility.html">Ogre::D3D11HLSLProgram::CmdEnableBackwardsCompatibility</a></td><td class="indexvalue">Command object for setting backwards compatibility </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESCgProgram_1_1CmdEntryPoint.html">Ogre::GLSLESCgProgram::CmdEntryPoint</a></td><td class="indexvalue">Command object for setting entry point </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram_1_1CmdEntryPoint.html">Ogre::D3D11HLSLProgram::CmdEntryPoint</a></td><td class="indexvalue">Command object for setting entry point </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdEntryPoint.html">Ogre::D3D9HLSLProgram::CmdEntryPoint</a></td><td class="indexvalue">Command object for setting entry point </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuProgram_1_1CmdExternalMicrocode.html">Ogre::D3D9GpuProgram::CmdExternalMicrocode</a></td><td class="indexvalue">Command object for getting/setting external micro code (void*) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdFontName.html">Ogre::TextAreaOverlayElement::CmdFontName</a></td><td class="indexvalue">Command object for setting the caption </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSource_1_1CmdFPS.html">Ogre::ExternalTextureSource::CmdFPS</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdHeight.html">Ogre::OverlayElementCommands::CmdHeight</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdHeight.html">Ogre::ParticleSystem::CmdHeight</a></td><td class="indexvalue">Command object for particle_height (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdHorizontalAlign.html">Ogre::OverlayElementCommands::CmdHorizontalAlign</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSource_1_1CmdInputFileName.html">Ogre::ExternalTextureSource::CmdInputFileName</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram_1_1CmdInputOperationType.html">Ogre::GLSLProgram::CmdInputOperationType</a></td><td class="indexvalue">Command object for setting the input operation type (geometry shader only) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdIterationInterval.html">Ogre::ParticleSystem::CmdIterationInterval</a></td><td class="indexvalue">Command object for iteration interval(see ParamCommand) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdLeft.html">Ogre::OverlayElementCommands::CmdLeft</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdLocalSpace.html">Ogre::ParticleSystem::CmdLocalSpace</a></td><td class="indexvalue">Command object for local space (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdManualNamedConstsFile.html">Ogre::GpuProgram::CmdManualNamedConstsFile</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdMaterial.html">Ogre::OverlayElementCommands::CmdMaterial</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdMaterial.html">Ogre::ParticleSystem::CmdMaterial</a></td><td class="indexvalue">Command object for material (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMaxDuration.html">Ogre::EmitterCommands::CmdMaxDuration</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram_1_1CmdMaxOutputVertices.html">Ogre::GLSLProgram::CmdMaxOutputVertices</a></td><td class="indexvalue">Command object for setting the maximum output vertices (geometry shader only) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMaxRepeatDelay.html">Ogre::EmitterCommands::CmdMaxRepeatDelay</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMaxTTL.html">Ogre::EmitterCommands::CmdMaxTTL</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMaxVelocity.html">Ogre::EmitterCommands::CmdMaxVelocity</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdMetricsMode.html">Ogre::OverlayElementCommands::CmdMetricsMode</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdMicrocode.html">Ogre::D3D9HLSLProgram::CmdMicrocode</a></td><td class="indexvalue">Command object for getting/setting micro code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMinDuration.html">Ogre::EmitterCommands::CmdMinDuration</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMinRepeatDelay.html">Ogre::EmitterCommands::CmdMinRepeatDelay</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMinTTL.html">Ogre::EmitterCommands::CmdMinTTL</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdMinVelocity.html">Ogre::EmitterCommands::CmdMinVelocity</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdMorph.html">Ogre::GpuProgram::CmdMorph</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdName.html">Ogre::EmitterCommands::CmdName</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdNonvisibleTimeout.html">Ogre::ParticleSystem::CmdNonvisibleTimeout</a></td><td class="indexvalue">Command object for nonvisible timeout (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgram_1_1CmdOptimisation.html">Ogre::GLSLESProgram::CmdOptimisation</a></td><td class="indexvalue">Command object for running the GLSL optimiser </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdOptimisation.html">Ogre::D3D9HLSLProgram::CmdOptimisation</a></td><td class="indexvalue">Command object for setting optimisation level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram_1_1CmdOutputOperationType.html">Ogre::GLSLProgram::CmdOutputOperationType</a></td><td class="indexvalue">Command object for setting the output operation type (geometry shader only) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSource_1_1CmdPlayMode.html">Ogre::ExternalTextureSource::CmdPlayMode</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardParticleRenderer_1_1CmdPointRendering.html">Ogre::BillboardParticleRenderer::CmdPointRendering</a></td><td class="indexvalue">Command object for point rendering (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdPose.html">Ogre::GpuProgram::CmdPose</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdPosition.html">Ogre::EmitterCommands::CmdPosition</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgram_1_1CmdPreprocessorDefines.html">Ogre::GLSLESProgram::CmdPreprocessorDefines</a></td><td class="indexvalue">Command object for setting macro defines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram_1_1CmdPreprocessorDefines.html">Ogre::D3D11HLSLProgram::CmdPreprocessorDefines</a></td><td class="indexvalue">Command object for setting macro defines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdPreprocessorDefines.html">Ogre::D3D9HLSLProgram::CmdPreprocessorDefines</a></td><td class="indexvalue">Command object for setting macro defines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram_1_1CmdPreprocessorDefines.html">Ogre::GLSLProgram::CmdPreprocessorDefines</a></td><td class="indexvalue">Command object for setting macro defines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESCgProgram_1_1CmdProfiles.html">Ogre::GLSLESCgProgram::CmdProfiles</a></td><td class="indexvalue">Command object for setting profiles </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdQuota.html">Ogre::ParticleSystem::CmdQuota</a></td><td class="indexvalue">Command object for quota (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdRenderer.html">Ogre::ParticleSystem::CmdRenderer</a></td><td class="indexvalue">Command object for renderer (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdRepeatDelay.html">Ogre::EmitterCommands::CmdRepeatDelay</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdResolution.html">Ogre::Font::CmdResolution</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdSize.html">Ogre::Font::CmdSize</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdSkeletal.html">Ogre::GpuProgram::CmdSkeletal</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdSorted.html">Ogre::ParticleSystem::CmdSorted</a></td><td class="indexvalue">Command object for sorting (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdSource.html">Ogre::Font::CmdSource</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement_1_1CmdSpaceWidth.html">Ogre::TextAreaOverlayElement::CmdSpaceWidth</a></td><td class="indexvalue">Command object for setting the width of a space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdSyntax.html">Ogre::GpuProgram::CmdSyntax</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram_1_1CmdTarget.html">Ogre::D3D11HLSLProgram::CmdTarget</a></td><td class="indexvalue">Command object for setting target assembler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram_1_1CmdTarget.html">Ogre::D3D9HLSLProgram::CmdTarget</a></td><td class="indexvalue">Command object for setting target assembler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSource_1_1CmdTecPassState.html">Ogre::ExternalTextureSource::CmdTecPassState</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PanelOverlayElement_1_1CmdTiling.html">Ogre::PanelOverlayElement::CmdTiling</a></td><td class="indexvalue">Command object for specifying tiling (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdTop.html">Ogre::OverlayElementCommands::CmdTop</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PanelOverlayElement_1_1CmdTransparent.html">Ogre::PanelOverlayElement::CmdTransparent</a></td><td class="indexvalue">Command object for specifying transparency (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdTTL.html">Ogre::EmitterCommands::CmdTTL</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font_1_1CmdType.html">Ogre::Font::CmdType</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdType.html">Ogre::GpuProgram::CmdType</a></td><td class="indexvalue">Command object - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdUp.html">Ogre::EmitterCommands::CmdUp</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PanelOverlayElement_1_1CmdUVCoords.html">Ogre::PanelOverlayElement::CmdUVCoords</a></td><td class="indexvalue">Command object for specifying UV coordinates (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmitterCommands_1_1CmdVelocity.html">Ogre::EmitterCommands::CmdVelocity</a></td><td class="indexvalue">Command object for particle emitter - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdVerticalAlign.html">Ogre::OverlayElementCommands::CmdVerticalAlign</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdVisible.html">Ogre::OverlayElementCommands::CmdVisible</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram_1_1CmdVTF.html">Ogre::GpuProgram::CmdVTF</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementCommands_1_1CmdWidth.html">Ogre::OverlayElementCommands::CmdWidth</a></td><td class="indexvalue">Command object for <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> - see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem_1_1CmdWidth.html">Ogre::ParticleSystem::CmdWidth</a></td><td class="indexvalue">Command object for particle_width (see <a class="el" href="classOgre_1_1ParamCommand.html" title="Abstract class which is command object which gets/sets parameters.">ParamCommand</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Codec.html">Ogre::Codec</a></td><td class="indexvalue">Abstract class that defines a 'codec' </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Codec_1_1CodecData.html">Ogre::Codec::CodecData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ColourValue.html">Ogre::ColourValue</a></td><td class="indexvalue">Class representing colour </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeListBuilder_1_1CommonVertex.html">Ogre::EdgeListBuilder::CommonVertex</a></td><td class="indexvalue">A vertex can actually represent several vertices in the final model, because vertices along texture seams etc will have been duplicated </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionPass.html">Ogre::CompositionPass</a></td><td class="indexvalue">Object representing one pass or operation in a composition sequence </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionPassTranslator.html">Ogre::CompositionPassTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionTargetPass.html">Ogre::CompositionTargetPass</a></td><td class="indexvalue">Object representing one render to a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> or <a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a> in the <a class="el" href="namespaceOgre.html">Ogre</a> Composition framework </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionTargetPassTranslator.html">Ogre::CompositionTargetPassTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionTechnique.html">Ogre::CompositionTechnique</a></td><td class="indexvalue">Base composition technique, can be subclassed in plugins </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionTechniqueTranslator.html">Ogre::CompositionTechniqueTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Compositor.html">Ogre::Compositor</a></td><td class="indexvalue">Class representing a <a class="el" href="classOgre_1_1Compositor.html" title="Class representing a Compositor object.">Compositor</a> object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorChain.html">Ogre::CompositorChain</a></td><td class="indexvalue">Chain of compositor effects applying to one viewport </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorInstance.html">Ogre::CompositorInstance</a></td><td class="indexvalue">An instance of a <a class="el" href="classOgre_1_1Compositor.html" title="Class representing a Compositor object.">Compositor</a> object for one <a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorLogic.html">Ogre::CompositorLogic</a></td><td class="indexvalue">Interface for compositor logics, which can be automatically binded to compositors, allowing per-compositor logic (such as attaching a relevant listener) to happen automatically </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorManager.html">Ogre::CompositorManager</a></td><td class="indexvalue">Class for managing <a class="el" href="classOgre_1_1Compositor.html" title="Class representing a Compositor object.">Compositor</a> settings for <a class="el" href="namespaceOgre.html">Ogre</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorPtr.html">Ogre::CompositorPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1CompositorPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to CompositorPtr.">CompositorPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorTranslator.html">Ogre::CompositorTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ConcreteNode.html">Ogre::ConcreteNode</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ConfigDialog.html">Ogre::ConfigDialog</a></td><td class="indexvalue">Defines the behaviour of an automatic renderer configuration dialog </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ConfigFile.html">Ogre::ConfigFile</a></td><td class="indexvalue">Class for quickly loading settings from a text file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ConstMapIterator.html">Ogre::ConstMapIterator&lt; T &gt;</a></td><td class="indexvalue">Concrete <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for const access to the underlying key-value container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ConstMapRange.html">Ogre::ConstMapRange&lt; T &gt;</a></td><td class="indexvalue">Predefined type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ConstParameter.html">Ogre::RTShader::ConstParameter&lt; valueType &gt;</a></td><td class="indexvalue">Helper template which is the base for our ConstParameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ConstVectorIterator.html">Ogre::ConstVectorIterator&lt; T &gt;</a></td><td class="indexvalue">Concrete <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for const access to the underlying container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ConstVectorRange.html">Ogre::ConstVectorRange&lt; T &gt;</a></td><td class="indexvalue">Predefined type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Controller.html">Ogre::Controller&lt; T &gt;</a></td><td class="indexvalue">Instances of this class 'control' the value of another object in the system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ControllerFunction.html">Ogre::ControllerFunction&lt; T &gt;</a></td><td class="indexvalue">Subclasses of this class are responsible for performing a function on an input value for a <a class="el" href="classOgre_1_1Controller.html" title="Instances of this class &#39;control&#39; the value of another object in the system.">Controller</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ControllerManager.html">Ogre::ControllerManager</a></td><td class="indexvalue">Class for managing <a class="el" href="classOgre_1_1Controller.html" title="Instances of this class &#39;control&#39; the value of another object in the system.">Controller</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ControllerValue.html">Ogre::ControllerValue&lt; T &gt;</a></td><td class="indexvalue">Can either be used as an input or output value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ConvexBody.html">Ogre::ConvexBody</a></td><td class="indexvalue">Holds a solid representation of a convex body </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuSharedParametersUsage_1_1CopyDataEntry.html">Ogre::GpuSharedParametersUsage::CopyDataEntry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CPreprocessor.html">Ogre::CPreprocessor</a></td><td class="indexvalue">This is a simplistic C/C++-like preprocessor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateCompositorScriptCompilerEvent.html">Ogre::CreateCompositorScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateGpuProgramScriptCompilerEvent.html">Ogre::CreateGpuProgramScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateGpuSharedParametersScriptCompilerEvent.html">Ogre::CreateGpuSharedParametersScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateHighLevelGpuProgramScriptCompilerEvent.html">Ogre::CreateHighLevelGpuProgramScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateMaterialScriptCompilerEvent.html">Ogre::CreateMaterialScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CreateParticleSystemScriptCompilerEvent.html">Ogre::CreateParticleSystemScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLSLLinkProgram_1_1CustomAttribute.html">Ogre::GLSLLinkProgram::CustomAttribute</a></td><td class="indexvalue">Name / attribute list </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CustomCompositionPass.html">Ogre::CustomCompositionPass</a></td><td class="indexvalue">Interface for custom composition passes, allowing custom operations (in addition to the quad, scene and clear operations) in composition passes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11DepthBuffer.html">Ogre::D3D11DepthBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11Device.html">Ogre::D3D11Device</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11Driver.html">Ogre::D3D11Driver</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11DriverList.html">Ogre::D3D11DriverList</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11GpuFragmentProgram.html">Ogre::D3D11GpuFragmentProgram</a></td><td class="indexvalue">Direct3D implementation of low-level fragment programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11GpuProgram.html">Ogre::D3D11GpuProgram</a></td><td class="indexvalue">Direct3D implementation of a few things common to low-level vertex &amp; fragment programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11GpuProgramManager.html">Ogre::D3D11GpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11GpuProgramPtr.html">Ogre::D3D11GpuProgramPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1D3D11GpuProgramPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to D3D11GpuProgramPtr.">D3D11GpuProgramPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11GpuVertexProgram.html">Ogre::D3D11GpuVertexProgram</a></td><td class="indexvalue">Direct3D implementation of low-level vertex programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareBuffer.html">Ogre::D3D11HardwareBuffer</a></td><td class="indexvalue">Base implementation of a D3D11 buffer, dealing with all the common aspects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareBufferManager.html">Ogre::D3D11HardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1D3D11HardwareBufferManagerBase.html" title="Implementation of HardwareBufferManager for D3D11.">D3D11HardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareBufferManagerBase.html">Ogre::D3D11HardwareBufferManagerBase</a></td><td class="indexvalue">Implementation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for D3D11 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareIndexBuffer.html">Ogre::D3D11HardwareIndexBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareOcclusionQuery.html">Ogre::D3D11HardwareOcclusionQuery</a></td><td class="indexvalue">This is a class that is the DirectX9 implementation of hardware occlusion testing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwarePixelBuffer.html">Ogre::D3D11HardwarePixelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HardwareVertexBuffer.html">Ogre::D3D11HardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for D3D11 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgram.html">Ogre::D3D11HLSLProgram</a></td><td class="indexvalue">Specialization of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for D3D11 High-Level Shader Language (HLSL) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11HLSLProgramFactory.html">Ogre::D3D11HLSLProgramFactory</a></td><td class="indexvalue">Factory class for D3D11 HLSL programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11Mappings.html">Ogre::D3D11Mappings</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11MultiRenderTarget.html">Ogre::D3D11MultiRenderTarget</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11Plugin.html">Ogre::D3D11Plugin</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Plugin.html" title="Class defining a generic OGRE plugin.">Plugin</a> instance for D3D11 Manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11RenderSystem.html">Ogre::D3D11RenderSystem</a></td><td class="indexvalue">Implementation of DirectX9 as a rendering system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11RenderTexture.html">Ogre::D3D11RenderTexture</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderTexture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> implementation for D3D11 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11RenderToVertexBuffer.html">Ogre::D3D11RenderToVertexBuffer</a></td><td class="indexvalue">An object which renders geometry to a vertex </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11RenderWindow.html">Ogre::D3D11RenderWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11Texture.html">Ogre::D3D11Texture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11TextureManager.html">Ogre::D3D11TextureManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11TexturePtr.html">Ogre::D3D11TexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1D3D11TexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to D3D11TexturePtr.">D3D11TexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11VertexDeclaration.html">Ogre::D3D11VertexDeclaration</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1VertexDeclaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> for D3D11 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11VideoMode.html">Ogre::D3D11VideoMode</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D11VideoModeList.html">Ogre::D3D11VideoModeList</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9DepthBuffer.html">Ogre::D3D9DepthBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Device.html">Ogre::D3D9Device</a></td><td class="indexvalue">High level interface of Direct3D9 Device </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9DeviceManager.html">Ogre::D3D9DeviceManager</a></td><td class="indexvalue">Device manager interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Driver.html">Ogre::D3D9Driver</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9DriverList.html">Ogre::D3D9DriverList</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuFragmentProgram.html">Ogre::D3D9GpuFragmentProgram</a></td><td class="indexvalue">Direct3D implementation of low-level fragment programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuProgram.html">Ogre::D3D9GpuProgram</a></td><td class="indexvalue">Direct3D implementation of a few things common to low-level vertex &amp; fragment programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuProgramManager.html">Ogre::D3D9GpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuProgramPtr.html">Ogre::D3D9GpuProgramPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1D3D9GpuProgramPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to D3D9GpuProgramPtr.">D3D9GpuProgramPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9GpuVertexProgram.html">Ogre::D3D9GpuVertexProgram</a></td><td class="indexvalue">Direct3D implementation of low-level vertex programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwareBufferManager.html">Ogre::D3D9HardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1D3D9HardwareBufferManagerBase.html" title="Implementation of HardwareBufferManager for D3D9.">D3D9HardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwareBufferManagerBase.html">Ogre::D3D9HardwareBufferManagerBase</a></td><td class="indexvalue">Implementation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for D3D9 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwareIndexBuffer.html">Ogre::D3D9HardwareIndexBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwareOcclusionQuery.html">Ogre::D3D9HardwareOcclusionQuery</a></td><td class="indexvalue">This is a class that is the DirectX9 implementation of hardware occlusion testing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwarePixelBuffer.html">Ogre::D3D9HardwarePixelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HardwareVertexBuffer.html">Ogre::D3D9HardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for D3D9 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgram.html">Ogre::D3D9HLSLProgram</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for D3D9 High-Level Shader Language (HLSL) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9HLSLProgramFactory.html">Ogre::D3D9HLSLProgramFactory</a></td><td class="indexvalue">Factory class for D3D9 HLSL programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Mappings.html">Ogre::D3D9Mappings</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9MultiRenderTarget.html">Ogre::D3D9MultiRenderTarget</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Plugin.html">Ogre::D3D9Plugin</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Plugin.html" title="Class defining a generic OGRE plugin.">Plugin</a> instance for D3D9 Manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9RenderSystem.html">Ogre::D3D9RenderSystem</a></td><td class="indexvalue">Implementation of DirectX9 as a rendering system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9RenderTexture.html">Ogre::D3D9RenderTexture</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderTexture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> implementation for D3D9 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9RenderWindow.html">Ogre::D3D9RenderWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Resource.html">Ogre::D3D9Resource</a></td><td class="indexvalue">Represents a Direct3D rendering resource </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9ResourceManager.html">Ogre::D3D9ResourceManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9Texture.html">Ogre::D3D9Texture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9TextureManager.html">Ogre::D3D9TextureManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9TexturePtr.html">Ogre::D3D9TexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1D3D9TexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to D3D9TexturePtr.">D3D9TexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9VertexDeclaration.html">Ogre::D3D9VertexDeclaration</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1VertexDeclaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> for D3D9 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9VideoMode.html">Ogre::D3D9VideoMode</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1D3D9VideoModeList.html">Ogre::D3D9VideoModeList</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DataStream.html">Ogre::DataStream</a></td><td class="indexvalue">General purpose class used for encapsulating the reading and writing of data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DDSCodec.html">Ogre::DDSCodec</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> specialized in loading DDS (Direct Draw Surface) images </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Node_1_1DebugRenderable.html">Ogre::Node::DebugRenderable</a></td><td class="indexvalue">Inner class for displaying debug renderable for <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultAxisAlignedBoxSceneQuery.html">Ogre::DefaultAxisAlignedBoxSceneQuery</a></td><td class="indexvalue">Default implementation of <a class="el" href="classOgre_1_1AxisAlignedBoxSceneQuery.html" title="Specialises the SceneQuery class for querying within an axis aligned box.">AxisAlignedBoxSceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Terrain_1_1DefaultGpuBufferAllocator.html">Ogre::Terrain::DefaultGpuBufferAllocator</a></td><td class="indexvalue">Standard implementation of a buffer allocator which re-uses buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultHardwareBufferManager.html">Ogre::DefaultHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1DefaultHardwareBufferManager.html" title="DefaultHardwareBufferManager as a Singleton.">DefaultHardwareBufferManager</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultHardwareBufferManagerBase.html">Ogre::DefaultHardwareBufferManagerBase</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBufferManagerBase.html" title="Base definition of a hardware buffer manager.">HardwareBufferManagerBase</a> to emulate hardware buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultHardwareIndexBuffer.html">Ogre::DefaultHardwareIndexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareIndexBuffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultHardwareVertexBuffer.html">Ogre::DefaultHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultIntersectionSceneQuery.html">Ogre::DefaultIntersectionSceneQuery</a></td><td class="indexvalue">Default implementation of <a class="el" href="classOgre_1_1IntersectionSceneQuery.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultPlaneBoundedVolumeListSceneQuery.html">Ogre::DefaultPlaneBoundedVolumeListSceneQuery</a></td><td class="indexvalue">Default implementation of <a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html" title="Specialises the SceneQuery class for querying within a plane-bounded volume.">PlaneBoundedVolumeListSceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultRaySceneQuery.html">Ogre::DefaultRaySceneQuery</a></td><td class="indexvalue">Default implementation of <a class="el" href="classOgre_1_1RaySceneQuery.html" title="Specialises the SceneQuery class for querying along a ray.">RaySceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultSceneManager.html">Ogre::DefaultSceneManager</a></td><td class="indexvalue">Default scene manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultSceneManagerFactory.html">Ogre::DefaultSceneManagerFactory</a></td><td class="indexvalue">Factory for default scene manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultShadowCameraSetup.html">Ogre::DefaultShadowCameraSetup</a></td><td class="indexvalue">Implements default shadow camera setup </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultSphereSceneQuery.html">Ogre::DefaultSphereSceneQuery</a></td><td class="indexvalue">Default implementation of <a class="el" href="classOgre_1_1SphereSceneQuery.html" title="Specialises the SceneQuery class for querying within a sphere.">SphereSceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultWorkQueue.html">Ogre::DefaultWorkQueue</a></td><td class="indexvalue">Implementation of a general purpose request / response style background work queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultWorkQueueBase.html">Ogre::DefaultWorkQueueBase</a></td><td class="indexvalue">Base for a general purpose request / response style background work queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DeflateStream.html">Ogre::DeflateStream</a></td><td class="indexvalue">Stream which compresses / uncompresses data using the 'deflate' compression algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Degree.html">Ogre::Degree</a></td><td class="indexvalue">Wrapper class which indicates a given angle value is in Degrees </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DepthBuffer.html">Ogre::DepthBuffer</a></td><td class="indexvalue">An abstract class that contains a depth/stencil buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1QueuedRenderableCollection_1_1DepthSortDescendingLess.html">Ogre::QueuedRenderableCollection::DepthSortDescendingLess</a></td><td class="indexvalue">Comparator to order objects by descending camera distance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1deque.html">Ogre::deque&lt; T, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Terrain_1_1DerivedDataRequest.html">Ogre::Terrain::DerivedDataRequest</a></td><td class="indexvalue">A data holder for communicating with the background derived data update </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Terrain_1_1DerivedDataResponse.html">Ogre::Terrain::DerivedDataResponse</a></td><td class="indexvalue">A data holder for communicating with the background derived data update </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Win32GLSupport_1_1DisplayMonitorInfo.html">Ogre::Win32GLSupport::DisplayMonitorInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DistanceLodStrategy.html">Ogre::DistanceLodStrategy</a></td><td class="indexvalue">Level of detail strategy based on distance from camera </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1DriverVersion.html">Ogre::DriverVersion</a></td><td class="indexvalue"><a class="el" href="structOgre_1_1DriverVersion.html" title="DriverVersion is used by RenderSystemCapabilities and both GL and D3D9 to store the version of the cu...">DriverVersion</a> is used by <a class="el" href="classOgre_1_1RenderSystemCapabilities.html" title="singleton class for storing the capabilities of the graphics card.">RenderSystemCapabilities</a> and both GL and D3D9 to store the version of the current GPU driver </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DualQuaternion.html">Ogre::DualQuaternion</a></td><td class="indexvalue">Implementation of a dual quaternion, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DynLib.html">Ogre::DynLib</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Resource.html" title="Abstract class representing a loadable resource (e.g.">Resource</a> holding data about a dynamic library </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DynLibManager.html">Ogre::DynLibManager</a></td><td class="indexvalue">Manager for Dynamic-loading Libraries </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGL2Support.html">Ogre::EAGL2Support</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="interfaceEAGL2ViewController.html">EAGL2ViewController</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGL2Window.html">Ogre::EAGL2Window</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGLES2Context.html">Ogre::EAGLES2Context</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGLESContext.html">Ogre::EAGLESContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGLPBuffer.html">Ogre::EAGLPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGLSupport.html">Ogre::EAGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="interfaceEAGLViewController.html">EAGLViewController</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EAGLWindow.html">Ogre::EAGLWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeData_1_1Edge.html">Ogre::EdgeData::Edge</a></td><td class="indexvalue"><a class="el" href="structOgre_1_1EdgeData_1_1Edge.html" title="Edge data.">Edge</a> data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EdgeData.html">Ogre::EdgeData</a></td><td class="indexvalue">This class contains the information required to describe the edge connectivity of a given set of vertices and indexes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeData_1_1EdgeGroup.html">Ogre::EdgeData::EdgeGroup</a></td><td class="indexvalue">A group of edges sharing the same vertex data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EdgeListBuilder.html">Ogre::EdgeListBuilder</a></td><td class="indexvalue">General utility class for building edge lists for geometry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EGLContext.html">Ogre::EGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EGLPBuffer.html">Ogre::EGLPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EGLSupport.html">Ogre::EGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EGLWindow.html">Ogre::EGLWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1BillboardChain_1_1Element.html">Ogre::BillboardChain::Element</a></td><td class="indexvalue">Contains the data of an element of the <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EmbeddedZipArchiveFactory.html">Ogre::EmbeddedZipArchiveFactory</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1ZipArchiveFactory.html" title="Specialisation of ArchiveFactory for Zip files.">ZipArchiveFactory</a> for embedded Zip files </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Entity.html">Ogre::Entity</a></td><td class="indexvalue">Defines an instance of a discrete, movable object based on a <a class="el" href="classOgre_1_1Mesh.html">Mesh</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1EntityFactory.html">Ogre::EntityFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EntityMaterialLodChangedEvent.html">Ogre::EntityMaterialLodChangedEvent</a></td><td class="indexvalue">Struct containing information about a material lod change event for entities </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EntityMeshLodChangedEvent.html">Ogre::EntityMeshLodChangedEvent</a></td><td class="indexvalue">Struct containing information about a mesh lod change event for entities </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Entity_1_1EntityShadowRenderable.html">Ogre::Entity::EntityShadowRenderable</a></td><td class="indexvalue">Nested class to allow entity shadows </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ScriptCompiler_1_1Error.html">Ogre::ScriptCompiler::Error</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ErrorDialog.html">Ogre::ErrorDialog</a></td><td class="indexvalue">Class for displaying the error dialog if <a class="el" href="namespaceOgre.html">Ogre</a> fails badly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageManager_1_1EventRouter.html">Ogre::PageManager::EventRouter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Exception.html">Ogre::Exception</a></td><td class="indexvalue">When thrown, provides information about an error that has occurred inside the engine </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ExceptionCodeType.html">Ogre::ExceptionCodeType&lt; num &gt;</a></td><td class="indexvalue">Template struct which creates a distinct type for each exception code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExceptionFactory.html">Ogre::ExceptionFactory</a></td><td class="indexvalue">Class implementing dispatch methods in order to construct by-value exceptions of a derived type based just on an exception code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSource.html">Ogre::ExternalTextureSource</a></td><td class="indexvalue">IMPORTANT: **Plugins must override default dictionary name!** Base class that texture plugins derive from </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ExternalTextureSourceManager.html">Ogre::ExternalTextureSourceManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> Class which handles the registering and control of texture plugins </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FactoryObj.html">Ogre::FactoryObj&lt; T &gt;</a></td><td class="indexvalue">Abstract factory class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FileHandleDataStream.html">Ogre::FileHandleDataStream</a></td><td class="indexvalue">Common subclass of <a class="el" href="classOgre_1_1DataStream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> for handling data from C-style file handles </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1FileInfo.html">Ogre::FileInfo</a></td><td class="indexvalue">Information about a file/directory within the archive will be returned using a <a class="el" href="structOgre_1_1FileInfo.html" title="Information about a file/directory within the archive will be returned using a FileInfo struct...">FileInfo</a> struct </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FileNotFoundException.html">Ogre::FileNotFoundException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FileStreamDataStream.html">Ogre::FileStreamDataStream</a></td><td class="indexvalue">Common subclass of <a class="el" href="classOgre_1_1DataStream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> for handling data from std::basic_istream </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FileSystemArchive.html">Ogre::FileSystemArchive</a></td><td class="indexvalue">Specialisation of the <a class="el" href="classOgre_1_1Archive.html" title="Archive-handling class.">Archive</a> class to allow reading of files from filesystem folders / directories </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FileSystemArchiveFactory.html">Ogre::FileSystemArchiveFactory</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1ArchiveFactory.html" title="Abstract factory class, archive codec plugins can register concrete subclasses of this...">ArchiveFactory</a> for FileSystem files </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FloatGpuParameterControllerValue.html">Ogre::FloatGpuParameterControllerValue</a></td><td class="indexvalue">Predefined controller value for setting a single floating- point value in a constant parameter of a vertex or fragment program </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Log_1_1Stream_1_1Flush.html">Ogre::Log::Stream::Flush</a></td><td class="indexvalue">Simple type to indicate a flush of the stream to the log </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FocusedShadowCameraSetup.html">Ogre::FocusedShadowCameraSetup</a></td><td class="indexvalue">Implements the uniform shadow mapping algorithm in focused mode </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Font.html">Ogre::Font</a></td><td class="indexvalue">Class representing a font in the system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FontManager.html">Ogre::FontManager</a></td><td class="indexvalue">Manages <a class="el" href="classOgre_1_1Font.html" title="Class representing a font in the system.">Font</a> resources, parsing .fontdef files and generally organising them </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FontPtr.html">Ogre::FontPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1FontPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to FontPtr.">FontPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLES2FBOManager_1_1FormatProperties.html">Ogre::GLES2FBOManager::FormatProperties</a></td><td class="indexvalue">Frame Buffer Object properties for a certain texture format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLFBOManager_1_1FormatProperties.html">Ogre::GLFBOManager::FormatProperties</a></td><td class="indexvalue">Frame Buffer Object properties for a certain texture format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESFBOManager_1_1FormatProperties.html">Ogre::GLESFBOManager::FormatProperties</a></td><td class="indexvalue">Frame Buffer Object properties for a certain texture format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1FrameEvent.html">Ogre::FrameEvent</a></td><td class="indexvalue">Struct containing information about a frame event </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FrameListener.html">Ogre::FrameListener</a></td><td class="indexvalue">A interface class defining a listener which can be used to receive notifications of frame events </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderTarget_1_1FrameStats.html">Ogre::RenderTarget::FrameStats</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FrameTimeControllerValue.html">Ogre::FrameTimeControllerValue</a></td><td class="indexvalue">Predefined controller value for getting the latest frame time </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FreeImageCodec.html">Ogre::FreeImageCodec</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> specialized in images loaded using FreeImage </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Frustum.html">Ogre::Frustum</a></td><td class="indexvalue">A frustum represents a pyramid, capped at the near and far end which is used to represent either a visible area or a projection area </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1Function.html">Ogre::RTShader::Function</a></td><td class="indexvalue">A class that represents a shader based program function </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1FunctionAtom.html">Ogre::RTShader::FunctionAtom</a></td><td class="indexvalue">A class that represents an atomic code section of shader based program function </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1FunctionInvocation.html">Ogre::RTShader::FunctionInvocation</a></td><td class="indexvalue">A class that represents function invocation code from shader based program function </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RTShader_1_1FunctionInvocation_1_1FunctionInvocationCompare.html">Ogre::RTShader::FunctionInvocation::FunctionInvocationCompare</a></td><td class="indexvalue">Comparator function to be used for comparisons </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RTShader_1_1FunctionInvocation_1_1FunctionInvocationLessThan.html">Ogre::RTShader::FunctionInvocation::FunctionInvocationLessThan</a></td><td class="indexvalue">Comparator function to be used for sorting </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeListBuilder_1_1Geometry.html">Ogre::EdgeListBuilder::Geometry</a></td><td class="indexvalue">A set of indexed geometry data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1GeometryBucket.html">Ogre::StaticGeometry::GeometryBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1StaticGeometry_1_1GeometryBucket.html" title="A GeometryBucket is a the lowest level bucket where geometry with the same vertex &amp; index format is s...">GeometryBucket</a> is a the lowest level bucket where geometry with the same vertex &amp; index format is stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1GeometryBucket.html">Ogre::InstancedGeometry::GeometryBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1InstancedGeometry_1_1GeometryBucket.html" title="A GeometryBucket is a the lowest level bucket where geometry with the same vertex &amp; index format is s...">GeometryBucket</a> is a the lowest level bucket where geometry with the same vertex &amp; index format is stored </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeListBuilder_1_1geometryLess.html">Ogre::EdgeListBuilder::geometryLess</a></td><td class="indexvalue">Comparator for sorting geometries by vertex set </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLArbGpuProgram.html">Ogre::GLArbGpuProgram</a></td><td class="indexvalue">Specialisation of the GL low-level program for ARB programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLContext.html">Ogre::GLContext</a></td><td class="indexvalue">Class that encapsulates an GL context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLCopyingRenderTexture.html">Ogre::GLCopyingRenderTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLCopyingRTTManager.html">Ogre::GLCopyingRTTManager</a></td><td class="indexvalue">Simple, copying manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLDefaultHardwareBufferManager.html">Ogre::GLDefaultHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLDefaultHardwareBufferManagerBase.html" title="Specialisation of HardwareBufferManager to emulate hardware buffers.">GLDefaultHardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLDefaultHardwareBufferManagerBase.html">Ogre::GLDefaultHardwareBufferManagerBase</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> to emulate hardware buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLDefaultHardwareIndexBuffer.html">Ogre::GLDefaultHardwareIndexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareIndexBuffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLDefaultHardwareVertexBuffer.html">Ogre::GLDefaultHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLDepthBuffer.html">Ogre::GLDepthBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2Context.html">Ogre::GLES2Context</a></td><td class="indexvalue">Class that encapsulates an GL context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2CopyingRenderTexture.html">Ogre::GLES2CopyingRenderTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2CopyingRTTManager.html">Ogre::GLES2CopyingRTTManager</a></td><td class="indexvalue">Simple, copying manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2DefaultHardwareBufferManager.html">Ogre::GLES2DefaultHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLES2DefaultHardwareBufferManagerBase.html" title="Specialisation of HardwareBufferManager to emulate hardware buffers.">GLES2DefaultHardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2DefaultHardwareBufferManagerBase.html">Ogre::GLES2DefaultHardwareBufferManagerBase</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> to emulate hardware buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2DefaultHardwareIndexBuffer.html">Ogre::GLES2DefaultHardwareIndexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareIndexBuffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2DefaultHardwareVertexBuffer.html">Ogre::GLES2DefaultHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2DepthBuffer.html">Ogre::GLES2DepthBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2FBOManager.html">Ogre::GLES2FBOManager</a></td><td class="indexvalue">Factory for GL ES 2 Frame Buffer Objects, and related things </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2FBOMultiRenderTarget.html">Ogre::GLES2FBOMultiRenderTarget</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MultiRenderTarget.html" title="This class represents a render target that renders to multiple RenderTextures at once.">MultiRenderTarget</a> for GL ES 2.x </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2FBORenderTexture.html">Ogre::GLES2FBORenderTexture</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderTexture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> for GL ES 2 FBO </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2FrameBufferObject.html">Ogre::GLES2FrameBufferObject</a></td><td class="indexvalue">Frame Buffer Object abstraction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2GpuProgram.html">Ogre::GLES2GpuProgram</a></td><td class="indexvalue">Generalised low-level GL program, can be applied to multiple types (eg ARB and NV) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2GpuProgramManager.html">Ogre::GLES2GpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwareBufferManager.html">Ogre::GLES2HardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLES2HardwareBufferManagerBase.html" title="Implementation of HardwareBufferManager for OpenGL ES.">GLES2HardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwareBufferManagerBase.html">Ogre::GLES2HardwareBufferManagerBase</a></td><td class="indexvalue">Implementation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for OpenGL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwareIndexBuffer.html">Ogre::GLES2HardwareIndexBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwareOcclusionQuery.html">Ogre::GLES2HardwareOcclusionQuery</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwarePixelBuffer.html">Ogre::GLES2HardwarePixelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2HardwareVertexBuffer.html">Ogre::GLES2HardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for OpenGL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2PixelUtil.html">Ogre::GLES2PixelUtil</a></td><td class="indexvalue">Class to do pixel format mapping between GL and OGRE </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2Plugin.html">Ogre::GLES2Plugin</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Plugin.html" title="Class defining a generic OGRE plugin.">Plugin</a> instance for GL ES 2 Manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2RenderBuffer.html">Ogre::GLES2RenderBuffer</a></td><td class="indexvalue">Renderbuffer surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2RenderSystem.html">Ogre::GLES2RenderSystem</a></td><td class="indexvalue">Implementation of GL ES 2.x as a rendering system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2RenderTexture.html">Ogre::GLES2RenderTexture</a></td><td class="indexvalue">Base class for GL Render Textures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2RTTManager.html">Ogre::GLES2RTTManager</a></td><td class="indexvalue">Manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2Support.html">Ogre::GLES2Support</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLES2SurfaceDesc.html">Ogre::GLES2SurfaceDesc</a></td><td class="indexvalue">GL surface descriptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2Texture.html">Ogre::GLES2Texture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2TextureBuffer.html">Ogre::GLES2TextureBuffer</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2TextureManager.html">Ogre::GLES2TextureManager</a></td><td class="indexvalue">GL ES-specific implementation of a <a class="el" href="classOgre_1_1TextureManager.html" title="Class for loading &amp; managing textures.">TextureManager</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLES2TexturePtr.html">Ogre::GLES2TexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1GLES2TexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to GLES2TexturePtr.">GLES2TexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESContext.html">Ogre::GLESContext</a></td><td class="indexvalue">Class that encapsulates an GL context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESCopyingRenderTexture.html">Ogre::GLESCopyingRenderTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESCopyingRTTManager.html">Ogre::GLESCopyingRTTManager</a></td><td class="indexvalue">Simple, copying manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESDefaultHardwareBufferManager.html">Ogre::GLESDefaultHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLESDefaultHardwareBufferManagerBase.html" title="Specialisation of HardwareBufferManager to emulate hardware buffers.">GLESDefaultHardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESDefaultHardwareBufferManagerBase.html">Ogre::GLESDefaultHardwareBufferManagerBase</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> to emulate hardware buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESDefaultHardwareIndexBuffer.html">Ogre::GLESDefaultHardwareIndexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareIndexBuffer.html" title="Specialisation of HardwareBuffer for vertex index buffers, still abstract.">HardwareIndexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESDefaultHardwareVertexBuffer.html">Ogre::GLESDefaultHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for emulation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESDepthBuffer.html">Ogre::GLESDepthBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESFBOManager.html">Ogre::GLESFBOManager</a></td><td class="indexvalue">Factory for GL Frame Buffer Objects, and related things </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESFBOMultiRenderTarget.html">Ogre::GLESFBOMultiRenderTarget</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MultiRenderTarget.html" title="This class represents a render target that renders to multiple RenderTextures at once.">MultiRenderTarget</a> for GL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESFBORenderTexture.html">Ogre::GLESFBORenderTexture</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderTexture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> for GL ES FBO </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESFrameBufferObject.html">Ogre::GLESFrameBufferObject</a></td><td class="indexvalue">Frame Buffer Object abstraction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESGpuProgramManager.html">Ogre::GLESGpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESHardwareBufferManager.html">Ogre::GLESHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLESHardwareBufferManagerBase.html" title="Implementation of HardwareBufferManager for OpenGL ES.">GLESHardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESHardwareBufferManagerBase.html">Ogre::GLESHardwareBufferManagerBase</a></td><td class="indexvalue">Implementation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for OpenGL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESHardwareIndexBuffer.html">Ogre::GLESHardwareIndexBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESHardwarePixelBuffer.html">Ogre::GLESHardwarePixelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESHardwareVertexBuffer.html">Ogre::GLESHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for OpenGL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESPBRenderTexture.html">Ogre::GLESPBRenderTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESPBRTTManager.html">Ogre::GLESPBRTTManager</a></td><td class="indexvalue">Manager for rendertextures and PBuffers (offscreen rendering contexts) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESPBuffer.html">Ogre::GLESPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESPixelUtil.html">Ogre::GLESPixelUtil</a></td><td class="indexvalue">Class to do pixel format mapping between GL and OGRE </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESPlugin.html">Ogre::GLESPlugin</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Plugin.html" title="Class defining a generic OGRE plugin.">Plugin</a> instance for GL Manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESRenderBuffer.html">Ogre::GLESRenderBuffer</a></td><td class="indexvalue">Renderbuffer surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESRenderSystem.html">Ogre::GLESRenderSystem</a></td><td class="indexvalue">Implementation of GL as a rendering system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESRenderTexture.html">Ogre::GLESRenderTexture</a></td><td class="indexvalue">Base class for GL Render Textures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESRTTManager.html">Ogre::GLESRTTManager</a></td><td class="indexvalue">Manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESSupport.html">Ogre::GLESSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESSurfaceDesc.html">Ogre::GLESSurfaceDesc</a></td><td class="indexvalue">GL surface descriptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESTexture.html">Ogre::GLESTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESTextureBuffer.html">Ogre::GLESTextureBuffer</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESTextureManager.html">Ogre::GLESTextureManager</a></td><td class="indexvalue">GL ES-specific implementation of a <a class="el" href="classOgre_1_1TextureManager.html" title="Class for loading &amp; managing textures.">TextureManager</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLESTexturePtr.html">Ogre::GLESTexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1GLESTexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to GLESTexturePtr.">GLESTexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLFBOManager.html">Ogre::GLFBOManager</a></td><td class="indexvalue">Factory for GL Frame Buffer Objects, and related things </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLFBOMultiRenderTarget.html">Ogre::GLFBOMultiRenderTarget</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MultiRenderTarget.html" title="This class represents a render target that renders to multiple RenderTextures at once.">MultiRenderTarget</a> for GL </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLFBORenderTexture.html">Ogre::GLFBORenderTexture</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderTexture.html" title="This class represents a RenderTarget that renders to a Texture.">RenderTexture</a> for GL FBO </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLFrameBufferObject.html">Ogre::GLFrameBufferObject</a></td><td class="indexvalue">Frame Buffer Object abstraction </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLGpuNvparseProgram.html">Ogre::GLGpuNvparseProgram</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLGpuProgram.html">Ogre::GLGpuProgram</a></td><td class="indexvalue">Generalised low-level GL program, can be applied to multiple types (eg ARB and NV) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLGpuProgramManager.html">Ogre::GLGpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwareBufferManager.html">Ogre::GLHardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1GLHardwareBufferManagerBase.html" title="Implementation of HardwareBufferManager for OpenGL.">GLHardwareBufferManagerBase</a> as a <a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwareBufferManagerBase.html">Ogre::GLHardwareBufferManagerBase</a></td><td class="indexvalue">Implementation of <a class="el" href="classOgre_1_1HardwareBufferManager.html" title="Singleton wrapper for hardware buffer manager.">HardwareBufferManager</a> for OpenGL </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwareIndexBuffer.html">Ogre::GLHardwareIndexBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwareOcclusionQuery.html">Ogre::GLHardwareOcclusionQuery</a></td><td class="indexvalue">This is a class that is the base class of the query class for hardware occlusion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwarePixelBuffer.html">Ogre::GLHardwarePixelBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLHardwareVertexBuffer.html">Ogre::GLHardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareVertexBuffer.html" title="Specialisation of HardwareBuffer for a vertex buffer.">HardwareVertexBuffer</a> for OpenGL </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLPBRenderTexture.html">Ogre::GLPBRenderTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLPBRTTManager.html">Ogre::GLPBRTTManager</a></td><td class="indexvalue">Manager for rendertextures and PBuffers (offscreen rendering contexts) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLPBuffer.html">Ogre::GLPBuffer</a></td><td class="indexvalue">An off-screen rendering context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLPixelUtil.html">Ogre::GLPixelUtil</a></td><td class="indexvalue">Class to do pixel format mapping between GL and OGRE </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLPlugin.html">Ogre::GLPlugin</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Plugin.html" title="Class defining a generic OGRE plugin.">Plugin</a> instance for GL Manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLRenderBuffer.html">Ogre::GLRenderBuffer</a></td><td class="indexvalue">Renderbuffer surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLRenderSystem.html">Ogre::GLRenderSystem</a></td><td class="indexvalue">Implementation of GL as a rendering system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLRenderTexture.html">Ogre::GLRenderTexture</a></td><td class="indexvalue">Base class for GL Render Textures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLRenderToVertexBuffer.html">Ogre::GLRenderToVertexBuffer</a></td><td class="indexvalue">An object which renders geometry to a vertex </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLRTTManager.html">Ogre::GLRTTManager</a></td><td class="indexvalue">Manager/factory for RenderTextures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESCgProgram.html">Ogre::GLSLESCgProgram</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for CG </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESCgProgramFactory.html">Ogre::GLSLESCgProgramFactory</a></td><td class="indexvalue">Factory class for GLSL ES programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESGpuProgram.html">Ogre::GLSLESGpuProgram</a></td><td class="indexvalue">GLSL ES low level compiled shader object - this class is used to get at the linked program object and provide an interface for <a class="el" href="classOgre_1_1GLES2RenderSystem.html" title="Implementation of GL ES 2.x as a rendering system.">GLES2RenderSystem</a> calls </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESLinkProgram.html">Ogre::GLSLESLinkProgram</a></td><td class="indexvalue">C++ encapsulation of GLSL ES Program Object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESLinkProgramManager.html">Ogre::GLSLESLinkProgramManager</a></td><td class="indexvalue"><a class="el" href="namespaceOgre.html">Ogre</a> assumes that there are separate vertex and fragment programs to deal with but GLSL ES has one program object that represents the active vertex and fragment shader objects during a rendering state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgram.html">Ogre::GLSLESProgram</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for OpenGL Shader Language (GLSL ES) for OpenGL ES 2.0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgramCommon.html">Ogre::GLSLESProgramCommon</a></td><td class="indexvalue">C++ encapsulation of GLSL ES Program Object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgramFactory.html">Ogre::GLSLESProgramFactory</a></td><td class="indexvalue">Factory class for GLSL ES programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgramManagerCommon.html">Ogre::GLSLESProgramManagerCommon</a></td><td class="indexvalue"><a class="el" href="namespaceOgre.html">Ogre</a> assumes that there are separate vertex and fragment programs to deal with but GLSL ES has one program object that represents the active vertex and fragment shader objects during a rendering state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgramPipeline.html">Ogre::GLSLESProgramPipeline</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for OpenGL Shader Language (GLSL ES) for OpenGL ES 2.0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLESProgramPipelineManager.html">Ogre::GLSLESProgramPipelineManager</a></td><td class="indexvalue"><a class="el" href="namespaceOgre.html">Ogre</a> assumes that there are separate vertex and fragment programs to deal with but GLSL ES has one program pipeline object that represents the active vertex and fragment program objects during a rendering state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1GLSLESProgramProcessor.html">Ogre::RTShader::GLSLESProgramProcessor</a></td><td class="indexvalue">GLSL ES Language program processor class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1GLSLESProgramWriter.html">Ogre::RTShader::GLSLESProgramWriter</a></td><td class="indexvalue">GLSL ES target language writer implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLGpuProgram.html">Ogre::GLSLGpuProgram</a></td><td class="indexvalue">GLSL low level compiled shader object - this class is used to get at the linked program object and provide an interface for <a class="el" href="classOgre_1_1GLRenderSystem.html" title="Implementation of GL as a rendering system.">GLRenderSystem</a> calls </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLLinkProgram.html">Ogre::GLSLLinkProgram</a></td><td class="indexvalue">C++ encapsulation of GLSL Program Object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLLinkProgramManager.html">Ogre::GLSLLinkProgramManager</a></td><td class="indexvalue"><a class="el" href="namespaceOgre.html">Ogre</a> assumes that there are separate vertex and fragment programs to deal with but GLSL has one program object that represents the active vertex and fragment shader objects during a rendering state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgram.html">Ogre::GLSLProgram</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> to provide support for OpenGL Shader Language (GLSL) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSLProgramFactory.html">Ogre::GLSLProgramFactory</a></td><td class="indexvalue">Factory class for GLSL programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1GLSLProgramProcessor.html">Ogre::RTShader::GLSLProgramProcessor</a></td><td class="indexvalue">GLSL Language program processor class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1GLSLProgramWriter.html">Ogre::RTShader::GLSLProgramWriter</a></td><td class="indexvalue">GLSL target language writer implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLSupport.html">Ogre::GLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLSurfaceDesc.html">Ogre::GLSurfaceDesc</a></td><td class="indexvalue">GL surface descriptor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLTexture.html">Ogre::GLTexture</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLTextureBuffer.html">Ogre::GLTextureBuffer</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> surface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLTextureManager.html">Ogre::GLTextureManager</a></td><td class="indexvalue">GL-specific implementation of a <a class="el" href="classOgre_1_1TextureManager.html" title="Class for loading &amp; managing textures.">TextureManager</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLTexturePtr.html">Ogre::GLTexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1GLTexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to GLTexturePtr.">GLTexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLUniformReference.html">Ogre::GLUniformReference</a></td><td class="indexvalue">Structure used to keep track of named uniforms in the linked program object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLXContext.html">Ogre::GLXContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLXGLSupport.html">Ogre::GLXGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLXPBuffer.html">Ogre::GLXPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLXUtils.html">Ogre::GLXUtils</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GLXWindow.html">Ogre::GLXWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Font_1_1GlyphInfo.html">Ogre::Font::GlyphInfo</a></td><td class="indexvalue">Information about the position and size of a glyph in a texture </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Terrain_1_1GpuBufferAllocator.html">Ogre::Terrain::GpuBufferAllocator</a></td><td class="indexvalue">Interface used to by the <a class="el" href="classOgre_1_1Terrain.html" title="The main containing class for a chunk of terrain.">Terrain</a> instance to allocate GPU buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuConstantDefinition.html">Ogre::GpuConstantDefinition</a></td><td class="indexvalue">Information about predefined program constants </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Technique_1_1GPUDeviceNameRule.html">Ogre::Technique::GPUDeviceNameRule</a></td><td class="indexvalue">Rule controlling whether technique is deemed supported based on GPU device name </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuLogicalBufferStruct.html">Ogre::GpuLogicalBufferStruct</a></td><td class="indexvalue">Container struct to allow params to safely &amp; update shared list of logical buffer assignments </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuLogicalIndexUse.html">Ogre::GpuLogicalIndexUse</a></td><td class="indexvalue">Structure recording the use of a physical buffer by a logical parameter index </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GpuNamedConstants.html">Ogre::GpuNamedConstants</a></td><td class="indexvalue">Struct collecting together the information for named constants </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuNamedConstantsSerializer.html">Ogre::GpuNamedConstantsSerializer</a></td><td class="indexvalue">Simple class for loading / saving <a class="el" href="structOgre_1_1GpuNamedConstants.html" title="Struct collecting together the information for named constants.">GpuNamedConstants</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgram.html">Ogre::GpuProgram</a></td><td class="indexvalue">Defines a program which runs on the GPU such as a vertex or fragment program </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramManager.html">Ogre::GpuProgramManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramParameters.html">Ogre::GpuProgramParameters</a></td><td class="indexvalue">Collects together the program parameters used for a <a class="el" href="classOgre_1_1GpuProgram.html" title="Defines a program which runs on the GPU such as a vertex or fragment program.">GpuProgram</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramPtr.html">Ogre::GpuProgramPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1GpuProgramPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to GpuProgramPtr.">GpuProgramPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramTranslator.html">Ogre::GpuProgramTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuProgramUsage.html">Ogre::GpuProgramUsage</a></td><td class="indexvalue">This class makes the usage of a vertex and fragment programs (low-level or high-level), with a given set of parameters, explicit </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuSharedParameters.html">Ogre::GpuSharedParameters</a></td><td class="indexvalue">A group of manually updated parameters that are shared between many parameter sets </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GpuSharedParametersUsage.html">Ogre::GpuSharedParametersUsage</a></td><td class="indexvalue">This class records the usage of a set of shared parameters in a concrete set of <a class="el" href="classOgre_1_1GpuProgramParameters.html" title="Collects together the program parameters used for a GpuProgram.">GpuProgramParameters</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Technique_1_1GPUVendorRule.html">Ogre::Technique::GPUVendorRule</a></td><td class="indexvalue">Rule controlling whether technique is deemed supported based on GPU vendor </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Grid2DPageStrategy.html">Ogre::Grid2DPageStrategy</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Page.html" title="Page class.">Page</a> strategy which loads new pages based on a regular 2D grid </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Grid2DPageStrategyData.html">Ogre::Grid2DPageStrategyData</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1PageStrategyData.html" title="Abstract marker class representing the data held against the PagedWorldSection which is specifically ...">PageStrategyData</a> for <a class="el" href="classOgre_1_1Grid2DPageStrategy.html" title="Page strategy which loads new pages based on a regular 2D grid.">Grid2DPageStrategy</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Grid3DPageStrategy.html">Ogre::Grid3DPageStrategy</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Page.html" title="Page class.">Page</a> strategy which loads new pages based on a regular 3D grid </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Grid3DPageStrategyData.html">Ogre::Grid3DPageStrategyData</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1PageStrategyData.html" title="Abstract marker class representing the data held against the PagedWorldSection which is specifically ...">PageStrategyData</a> for <a class="el" href="classOgre_1_1Grid3DPageStrategy.html" title="Page strategy which loads new pages based on a regular 3D grid.">Grid3DPageStrategy</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GTKGLSupport.html">Ogre::GTKGLSupport</a></td><td class="indexvalue">GL support in a GTK window </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1GTKWindow.html">Ogre::GTKWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1VertexData_1_1HardwareAnimationData.html">Ogre::VertexData::HardwareAnimationData</a></td><td class="indexvalue">Struct used to hold hardware morph / pose vertex data information </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareBuffer.html">Ogre::HardwareBuffer</a></td><td class="indexvalue">Abstract class defining common features of hardware buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareBufferLicensee.html">Ogre::HardwareBufferLicensee</a></td><td class="indexvalue">Abstract interface representing a 'licensee' of a hardware buffer copy </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1HardwareBufferLockGuard.html">Ogre::HardwareBufferLockGuard&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareBufferManager.html">Ogre::HardwareBufferManager</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> wrapper for hardware buffer manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareBufferManagerBase.html">Ogre::HardwareBufferManagerBase</a></td><td class="indexvalue">Base definition of a hardware buffer manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareIndexBuffer.html">Ogre::HardwareIndexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBuffer.html" title="Abstract class defining common features of hardware buffers.">HardwareBuffer</a> for vertex index buffers, still abstract </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareIndexBufferSharedPtr.html">Ogre::HardwareIndexBufferSharedPtr</a></td><td class="indexvalue">Shared pointer implementation used to share index buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareOcclusionQuery.html">Ogre::HardwareOcclusionQuery</a></td><td class="indexvalue">This is a abstract class that that provides the interface for the query class for hardware occlusion </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwarePixelBuffer.html">Ogre::HardwarePixelBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBuffer.html" title="Abstract class defining common features of hardware buffers.">HardwareBuffer</a> for a pixel buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwarePixelBufferSharedPtr.html">Ogre::HardwarePixelBufferSharedPtr</a></td><td class="indexvalue">Shared pointer implementation used to share pixel buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareVertexBuffer.html">Ogre::HardwareVertexBuffer</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HardwareBuffer.html" title="Abstract class defining common features of hardware buffers.">HardwareBuffer</a> for a vertex buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareVertexBufferSharedPtr.html">Ogre::HardwareVertexBufferSharedPtr</a></td><td class="indexvalue">Shared pointer implementation used to share index buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HashedVector.html">Ogre::HashedVector&lt; T &gt;</a></td><td class="indexvalue">A hashed vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Pass_1_1HashFunc.html">Ogre::Pass::HashFunc</a></td><td class="indexvalue">Definition of a functor for calculating the hashcode of a <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HighLevelGpuProgram.html">Ogre::HighLevelGpuProgram</a></td><td class="indexvalue">Abstract base class representing a high-level program (a vertex or fragment program) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HighLevelGpuProgramFactory.html">Ogre::HighLevelGpuProgramFactory</a></td><td class="indexvalue">Interface definition for factories of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HighLevelGpuProgramManager.html">Ogre::HighLevelGpuProgramManager</a></td><td class="indexvalue">This <a class="el" href="classOgre_1_1ResourceManager.html" title="Defines a generic resource handler.">ResourceManager</a> manages high-level vertex and fragment programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HighLevelGpuProgramPtr.html">Ogre::HighLevelGpuProgramPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1HighLevelGpuProgramPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to HighLevelGpuProgramPtr.">HighLevelGpuProgramPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1HLSLProgramProcessor.html">Ogre::RTShader::HLSLProgramProcessor</a></td><td class="indexvalue">CG Language program processor class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1HLSLProgramWriter.html">Ogre::RTShader::HLSLProgramWriter</a></td><td class="indexvalue">HLSL target language writer implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Any_1_1holder.html">Ogre::Any::holder&lt; ValueType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1IlluminationPass.html">Ogre::IlluminationPass</a></td><td class="indexvalue">Struct recording a pass which can be used for a specific illumination stage </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Image.html">Ogre::Image</a></td><td class="indexvalue">Class representing an image file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ImageCodec.html">Ogre::ImageCodec</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> specialized in images </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ImageCodec_1_1ImageData.html">Ogre::ImageCodec::ImageData</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> return class for images </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderTarget_1_1Impl.html">Ogre::RenderTarget::Impl</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1RenderSystem.html" title="Defines the functionality of a 3D API.">RenderSystem</a> specific interface for a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a>; this should be subclassed by RenderSystems </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ImportAbstractNode.html">Ogre::ImportAbstractNode</a></td><td class="indexvalue">This abstract node represents an import statement </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Terrain_1_1ImportData.html">Ogre::Terrain::ImportData</a></td><td class="indexvalue">Structure encapsulating import data that you may use to bootstrap the terrain without loading from a native data stream </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1IndexData.html">Ogre::IndexData</a></td><td class="indexvalue">Summary class collecting together index data source information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TangentSpaceCalc_1_1IndexRemap.html">Ogre::TangentSpaceCalc::IndexRemap</a></td><td class="indexvalue">Information about a remapped index </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1CompositionPass_1_1InputTex.html">Ogre::CompositionPass::InputTex</a></td><td class="indexvalue">Inputs (for material used for rendering the quad) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceBatch.html">Ogre::InstanceBatch</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1InstanceBatch.html" title="InstanceBatch forms part of the new Instancing system This is an abstract class that must be derived ...">InstanceBatch</a> forms part of the new Instancing system This is an abstract class that must be derived to implement different instancing techniques ( </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceBatchHW.html">Ogre::InstanceBatchHW</a></td><td class="indexvalue">This is technique requires true instancing hardware support </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceBatchHW__VTF.html">Ogre::InstanceBatchHW_VTF</a></td><td class="indexvalue">Instancing implementation using vertex texture through Vertex <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> Fetch (VTF) and hardware instancing </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceBatchShader.html">Ogre::InstanceBatchShader</a></td><td class="indexvalue">This is the same technique the old "InstancedGeometry" implementation used (with improvements) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceBatchVTF.html">Ogre::InstanceBatchVTF</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedEntity.html">Ogre::InstancedEntity</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry.html">Ogre::InstancedGeometry</a></td><td class="indexvalue">Pre-transforms and batches up meshes for efficient use as instanced geometry in a scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1InstancedObject.html">Ogre::InstancedGeometry::InstancedObject</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstanceManager.html">Ogre::InstanceManager</a></td><td class="indexvalue">This is the main starting point for the new instancing system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InternalErrorException.html">Ogre::InternalErrorException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1IntersectionSceneQuery.html">Ogre::IntersectionSceneQuery</a></td><td class="indexvalue">Separate <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> class to query for pairs of objects which are possibly intersecting one another </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1IntersectionSceneQueryListener.html">Ogre::IntersectionSceneQueryListener</a></td><td class="indexvalue">Alternative listener class for dealing with <a class="el" href="classOgre_1_1IntersectionSceneQuery.html" title="Separate SceneQuery class to query for pairs of objects which are possibly intersecting one another...">IntersectionSceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1IntersectionSceneQueryResult.html">Ogre::IntersectionSceneQueryResult</a></td><td class="indexvalue">Holds the results of an intersection scene query (pair values) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InvalidParametersException.html">Ogre::InvalidParametersException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InvalidStateException.html">Ogre::InvalidStateException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1IOException.html">Ogre::IOException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike.html">Ogre::isPodLike&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01bool_01_4.html">Ogre::isPodLike&lt; bool &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01char_01_4.html">Ogre::isPodLike&lt; char &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01double_01_4.html">Ogre::isPodLike&lt; double &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01float_01_4.html">Ogre::isPodLike&lt; float &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01int_01_4.html">Ogre::isPodLike&lt; int &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01long_01_4.html">Ogre::isPodLike&lt; long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01short_01_4.html">Ogre::isPodLike&lt; short &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01signed_01char_01_4.html">Ogre::isPodLike&lt; signed char &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01std_1_1pair_3_01T_00_01U_01_4_01_4.html">Ogre::isPodLike&lt; std::pair&lt; T, U &gt; &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01T_01_5_01_4.html">Ogre::isPodLike&lt; T * &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01unsigned_01_4.html">Ogre::isPodLike&lt; unsigned &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01unsigned_01char_01_4.html">Ogre::isPodLike&lt; unsigned char &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01unsigned_01long_01_4.html">Ogre::isPodLike&lt; unsigned long &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1isPodLike_3_01unsigned_01short_01_4.html">Ogre::isPodLike&lt; unsigned short &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ItemIdentityException.html">Ogre::ItemIdentityException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderQueueGroupMap_1_1iterator.html">Ogre::RenderQueue::RenderQueueGroupMap::iterator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1iterator__range.html">Ogre::iterator_range&lt; T &gt;</a></td><td class="indexvalue">Base for an <a class="el" href="classOgre_1_1iterator__range.html" title="Base for an iterator_range.">iterator_range</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1IteratorWrapper.html">Ogre::IteratorWrapper&lt; T, IteratorType, ValType &gt;</a></td><td class="indexvalue">Basefunctionality for IteratorWrappers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1KeyFrame.html">Ogre::KeyFrame</a></td><td class="indexvalue">A key frame in an animation sequence defined by an <a class="el" href="classOgre_1_1AnimationTrack.html" title="A &#39;track&#39; in an animation sequence, i.e.">AnimationTrack</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LayerBlendModeEx.html">Ogre::LayerBlendModeEx</a></td><td class="indexvalue">Class which manages blending of both colour and alpha components </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Terrain_1_1LayerInstance.html">Ogre::Terrain::LayerInstance</a></td><td class="indexvalue">An instance of a layer, with specific texture names </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Light.html">Ogre::Light</a></td><td class="indexvalue">Representation of a dynamic light source in the scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1LightClippingInfo.html">Ogre::SceneManager::LightClippingInfo</a></td><td class="indexvalue">Struct for cacheing light clipping information for re-use in a frame </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LightFactory.html">Ogre::LightFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1Light.html" title="Representation of a dynamic light source in the scene.">Light</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1LightInfo.html">Ogre::SceneManager::LightInfo</a></td><td class="indexvalue">Cached light information, used to tracking light's changes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1lightLess.html">Ogre::SceneManager::lightLess</a></td><td class="indexvalue">Comparator for sorting lights relative to a point </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1lightsForShadowTextureLess.html">Ogre::SceneManager::lightsForShadowTextureLess</a></td><td class="indexvalue">Default sorting routine which sorts lights which cast shadows to the front of a list, sub-sorting by distance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1LinearResampler.html">Ogre::LinearResampler</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1LinearResampler__Byte.html">Ogre::LinearResampler_Byte&lt; channels &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1LinearResampler__Float32.html">Ogre::LinearResampler_Float32</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1LinkedSkeletonAnimationSource.html">Ogre::LinkedSkeletonAnimationSource</a></td><td class="indexvalue">Link to another skeleton to share animations </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LiSPSMShadowCameraSetup.html">Ogre::LiSPSMShadowCameraSetup</a></td><td class="indexvalue">Implements the <a class="el" href="classOgre_1_1Light.html" title="Representation of a dynamic light source in the scene.">Light</a> Space Perspective Shadow Mapping Algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1list.html">Ogre::list&lt; T, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnimationTrack_1_1Listener.html">Ogre::AnimationTrack::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1AnimationTrack_1_1Listener.html" title="Listener allowing you to override certain behaviour of a track, for example to drive animation proced...">Listener</a> allowing you to override certain behaviour of a track, for example to drive animation procedurally </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialManager_1_1Listener.html">Ogre::MaterialManager::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MaterialManager_1_1Listener.html" title="Listener on any general material events.">Listener</a> on any general material events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialSerializer_1_1Listener.html">Ogre::MaterialSerializer::Listener</a></td><td class="indexvalue">Class that allows listening in on the various stages of material serialization process </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Camera_1_1Listener.html">Ogre::Camera::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Camera_1_1Listener.html" title="Listener interface so you can be notified of Camera events.">Listener</a> interface so you can be notified of <a class="el" href="classOgre_1_1Camera.html" title="A viewpoint from which the scene will be rendered.">Camera</a> events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MovableObject_1_1Listener.html">Ogre::MovableObject::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MovableObject_1_1Listener.html" title="Listener which gets called back on MovableObject events.">Listener</a> which gets called back on <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Node_1_1Listener.html">Ogre::Node::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Node_1_1Listener.html" title="Listener which gets called back on Node events.">Listener</a> which gets called back on <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Viewport_1_1Listener.html">Ogre::Viewport::Listener</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Viewport_1_1Listener.html" title="Listener interface so you can be notified of Viewport changes.">Listener</a> interface so you can be notified of <a class="el" href="classOgre_1_1Viewport.html" title="An abstraction of a viewport, i.e.">Viewport</a> changes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorInstance_1_1Listener.html">Ogre::CompositorInstance::Listener</a></td><td class="indexvalue">Provides an interface to "listen in" to to render system operations executed by this <a class="el" href="classOgre_1_1CompositorInstance.html" title="An instance of a Compositor object for one Viewport.">CompositorInstance</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderSystem_1_1Listener.html">Ogre::RenderSystem::Listener</a></td><td class="indexvalue">Defines a listener on the custom events that this render system can raise </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Resource_1_1Listener.html">Ogre::Resource::Listener</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceBackgroundQueue_1_1Listener.html">Ogre::ResourceBackgroundQueue::Listener</a></td><td class="indexvalue">This abstract listener interface lets you get notifications of completed background processes instead of having to poll ticket statuses </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManager_1_1Listener.html">Ogre::SceneManager::Listener</a></td><td class="indexvalue">Class that allows listening in on the various stages of <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> processing, so that custom behaviour can be implemented from outside </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainGroup_1_1LoadRequest.html">Ogre::TerrainGroup::LoadRequest</a></td><td class="indexvalue">Structure for holding the load request </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1LODBucket.html">Ogre::StaticGeometry::LODBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1StaticGeometry_1_1LODBucket.html" title="A LODBucket is a collection of smaller buckets with the same LOD.">LODBucket</a> is a collection of smaller buckets with the same LOD </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1LODBucket.html">Ogre::InstancedGeometry::LODBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1InstancedGeometry_1_1LODBucket.html" title="A LODBucket is a collection of smaller buckets with the same LOD.">LODBucket</a> is a collection of smaller buckets with the same LOD </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainQuadTreeNode_1_1LodLevel.html">Ogre::TerrainQuadTreeNode::LodLevel</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LodListener.html">Ogre::LodListener</a></td><td class="indexvalue">A interface class defining a listener which can be used to receive notifications of lod events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1LODBucket_1_1LODShadowRenderable.html">Ogre::StaticGeometry::LODBucket::LODShadowRenderable</a></td><td class="indexvalue">Nested class to allow shadows </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LodStrategy.html">Ogre::LodStrategy</a></td><td class="indexvalue">Strategy for determining level of detail </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LodStrategyManager.html">Ogre::LodStrategyManager</a></td><td class="indexvalue">Manager for lod strategies </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Log.html">Ogre::Log</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LogListener.html">Ogre::LogListener</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1LogManager.html">Ogre::LogManager</a></td><td class="indexvalue">The log manager handles the creation and retrieval of logs for the application </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CPreprocessor_1_1Macro.html">Ogre::CPreprocessor::Macro</a></td><td class="indexvalue">A macro definition </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ManualObject.html">Ogre::ManualObject</a></td><td class="indexvalue">Class providing a much simplified interface to generating manual objects with custom geometry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ManualObjectFactory.html">Ogre::ManualObjectFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1ManualObject.html" title="Class providing a much simplified interface to generating manual objects with custom geometry...">ManualObject</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ManualObject_1_1ManualObjectSection.html">Ogre::ManualObject::ManualObjectSection</a></td><td class="indexvalue">Built, renderable section of geometry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ManualObject_1_1ManualObjectSectionShadowRenderable.html">Ogre::ManualObject::ManualObjectSectionShadowRenderable</a></td><td class="indexvalue">Nested class to allow shadows </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ManualResourceLoader.html">Ogre::ManualResourceLoader</a></td><td class="indexvalue">Interface describing a manual resource loader </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1map.html">Ogre::map&lt; K, V, P, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MapIterator.html">Ogre::MapIterator&lt; T &gt;</a></td><td class="indexvalue">Concrete <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for nonconst access to the underlying key-value container </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MapIteratorWrapper.html">Ogre::MapIteratorWrapper&lt; T, IteratorType &gt;</a></td><td class="indexvalue">Prepiared <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for key-value container </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MapRange.html">Ogre::MapRange&lt; T &gt;</a></td><td class="indexvalue">Predefined type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Material.html">Ogre::Material</a></td><td class="indexvalue">Class encapsulates rendering properties of an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1MaterialBucket.html">Ogre::StaticGeometry::MaterialBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1StaticGeometry_1_1MaterialBucket.html" title="A MaterialBucket is a collection of smaller buckets with the same Material (and implicitly the same L...">MaterialBucket</a> is a collection of smaller buckets with the same <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> (and implicitly the same LOD) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1MaterialBucket.html">Ogre::InstancedGeometry::MaterialBucket</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1InstancedGeometry_1_1MaterialBucket.html" title="A MaterialBucket is a collection of smaller buckets with the same Material (and implicitly the same L...">MaterialBucket</a> is a collection of smaller buckets with the same <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> (and implicitly the same LOD) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1materialLess.html">Ogre::SceneManager::materialLess</a></td><td class="indexvalue">Comparator for material map, for sorting materials into render order (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialManager.html">Ogre::MaterialManager</a></td><td class="indexvalue">Class for managing <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> settings for <a class="el" href="namespaceOgre.html">Ogre</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialPtr.html">Ogre::MaterialPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1MaterialPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to MaterialPtr.">MaterialPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MaterialScriptContext.html">Ogre::MaterialScriptContext</a></td><td class="indexvalue">Struct for holding the script context while parsing </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MaterialScriptProgramDefinition.html">Ogre::MaterialScriptProgramDefinition</a></td><td class="indexvalue">Struct for holding a program definition which is in progress </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialSerializer.html">Ogre::MaterialSerializer</a></td><td class="indexvalue">Class for serializing Materials to / from a .material script </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MaterialTranslator.html">Ogre::MaterialTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RTShader_1_1ShaderGenerator_1_1MatGroupPair__less.html">Ogre::RTShader::ShaderGenerator::MatGroupPair_less</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Math.html">Ogre::Math</a></td><td class="indexvalue">Class to provide access to common mathematical functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Matrix3.html">Ogre::Matrix3</a></td><td class="indexvalue">A 3x3 matrix which can represent rotations around axes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Matrix4.html">Ogre::Matrix4</a></td><td class="indexvalue">Class encapsulating a standard 4x4 homogeneous matrix </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MemoryDataStream.html">Ogre::MemoryDataStream</a></td><td class="indexvalue">Common subclass of <a class="el" href="classOgre_1_1DataStream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> for handling data from chunks of memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RTShader_1_1ProgramProcessor_1_1MergeCombination.html">Ogre::RTShader::ProgramProcessor::MergeCombination</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramProcessor_1_1MergeParameter.html">Ogre::RTShader::ProgramProcessor::MergeParameter</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Mesh.html">Ogre::Mesh</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MeshManager_1_1MeshBuildParams.html">Ogre::MeshManager::MeshBuildParams</a></td><td class="indexvalue">Saved parameters used to (re)build a manual mesh built by this class </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MeshLodUsage.html">Ogre::MeshLodUsage</a></td><td class="indexvalue">A way of recording the way each LODs is recorded this <a class="el" href="classOgre_1_1Mesh.html">Mesh</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshManager.html">Ogre::MeshManager</a></td><td class="indexvalue">Handles the management of mesh resources </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshPtr.html">Ogre::MeshPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1MeshPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to MeshPtr.">MeshPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializer.html">Ogre::MeshSerializer</a></td><td class="indexvalue">Class for serialising mesh data to/from an OGRE .mesh file </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl.html">Ogre::MeshSerializerImpl</a></td><td class="indexvalue">Internal implementation of <a class="el" href="classOgre_1_1Mesh.html">Mesh</a> reading / writing for the latest version of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl__v1__1.html">Ogre::MeshSerializerImpl_v1_1</a></td><td class="indexvalue">Class for providing backwards-compatibility for loading version 1.1 of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl__v1__2.html">Ogre::MeshSerializerImpl_v1_2</a></td><td class="indexvalue">Class for providing backwards-compatibility for loading version 1.2 of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl__v1__3.html">Ogre::MeshSerializerImpl_v1_3</a></td><td class="indexvalue">Class for providing backwards-compatibility for loading version 1.3 of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl__v1__4.html">Ogre::MeshSerializerImpl_v1_4</a></td><td class="indexvalue">Class for providing backwards-compatibility for loading version 1.4 of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerImpl__v1__41.html">Ogre::MeshSerializerImpl_v1_41</a></td><td class="indexvalue">Class for providing backwards-compatibility for loading version 1.41 of the .mesh format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializerListener.html">Ogre::MeshSerializerListener</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MeshSerializer_1_1MeshVersionData.html">Ogre::MeshSerializer::MeshVersionData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLES2FBOManager_1_1FormatProperties_1_1Mode.html">Ogre::GLES2FBOManager::FormatProperties::Mode</a></td><td class="indexvalue">Allowed modes/properties for this pixel format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLFBOManager_1_1FormatProperties_1_1Mode.html">Ogre::GLFBOManager::FormatProperties::Mode</a></td><td class="indexvalue">Allowed modes/properties for this pixel format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESFBOManager_1_1FormatProperties_1_1Mode.html">Ogre::GLESFBOManager::FormatProperties::Mode</a></td><td class="indexvalue">Allowed modes/properties for this pixel format </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainQuadTreeNode_1_1Movable.html">Ogre::TerrainQuadTreeNode::Movable</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> implementation to provide the hook to the scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MovableObject.html">Ogre::MovableObject</a></td><td class="indexvalue">Abstract class defining a movable object in a scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1MovableObjectCollection.html">Ogre::SceneManager::MovableObjectCollection</a></td><td class="indexvalue">Simple structure to hold <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> map and a mutex to go with it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MovableObjectFactory.html">Ogre::MovableObjectFactory</a></td><td class="indexvalue">Interface definition for a factory class which produces a certain kind of <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a>, and can be registered with <a class="el" href="classOgre_1_1Root.html" title="The root class of the Ogre system.">Root</a> in order to allow all clients to produce new instances of this object, integrated with the standard <a class="el" href="namespaceOgre.html">Ogre</a> processing </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1MovableObjectLodChangedEvent.html">Ogre::MovableObjectLodChangedEvent</a></td><td class="indexvalue">Struct containing information about a lod change event for movable objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MovablePlane.html">Ogre::MovablePlane</a></td><td class="indexvalue">Definition of a <a class="el" href="classOgre_1_1Plane.html" title="Defines a plane in 3D space.">Plane</a> that may be attached to a node, and the derived details of it retrieved simply </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1multimap.html">Ogre::multimap&lt; K, V, P, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1MultiRenderTarget.html">Ogre::MultiRenderTarget</a></td><td class="indexvalue">This class represents a render target that renders to multiple RenderTextures at once </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NaClGLContext.html">Ogre::NaClGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NaClGLSupport.html">Ogre::NaClGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NaClWindow.html">Ogre::NaClWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NameGenerator.html">Ogre::NameGenerator</a></td><td class="indexvalue">Utility class to generate a sequentially numbered series of names </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1NearestResampler.html">Ogre::NearestResampler&lt; elemsize &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedAlignedAllocPolicy.html">Ogre::NedAlignedAllocPolicy&lt; Alignment &gt;</a></td><td class="indexvalue">An allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a>, which aligns memory at a given boundary (which should be a power of 2) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedAllocImpl.html">Ogre::NedAllocImpl</a></td><td class="indexvalue">Non-templated utility class just to hide nedmalloc </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedAllocPolicy.html">Ogre::NedAllocPolicy</a></td><td class="indexvalue">An allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedPoolingAlignedPolicy.html">Ogre::NedPoolingAlignedPolicy&lt; Alignment &gt;</a></td><td class="indexvalue">An allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a>, which aligns memory at a given boundary (which should be a power of 2) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedPoolingImpl.html">Ogre::NedPoolingImpl</a></td><td class="indexvalue">Non-templated utility class just to hide nedmalloc </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NedPoolingPolicy.html">Ogre::NedPoolingPolicy</a></td><td class="indexvalue">An allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Node.html">Ogre::Node</a></td><td class="indexvalue">Class representing a general-purpose node an articulated scene graph </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NodeAnimationTrack.html">Ogre::NodeAnimationTrack</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1AnimationTrack.html" title="A &#39;track&#39; in an animation sequence, i.e.">AnimationTrack</a> for dealing with node transforms </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NumericAnimationTrack.html">Ogre::NumericAnimationTrack</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1AnimationTrack.html" title="A &#39;track&#39; in an animation sequence, i.e.">AnimationTrack</a> for dealing with generic animable values </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NumericKeyFrame.html">Ogre::NumericKeyFrame</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1KeyFrame.html" title="A key frame in an animation sequence defined by an AnimationTrack.">KeyFrame</a> which stores any numeric value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1NumericSolver.html">Ogre::NumericSolver</a></td><td class="indexvalue">Provides numeric solvers for <a class="el" href="namespaceOgre.html">Ogre</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnyNumeric_1_1numholder.html">Ogre::AnyNumeric::numholder&lt; ValueType &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1AnyNumeric_1_1numplaceholder.html">Ogre::AnyNumeric::numplaceholder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ObjectAbstractNode.html">Ogre::ObjectAbstractNode</a></td><td class="indexvalue">This specific abstract node represents a script object </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1DefaultWorkQueueBase_1_1OGRE__THREAD__WORKER__INHERIT.html">Ogre::DefaultWorkQueueBase::OGRE_THREAD_WORKER_INHERIT</a></td><td class="indexvalue">Thread function </td></tr>
  <tr><td class="indexkey"><a class="el" href="interfaceOgreView.html">OgreView</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OGREWidget.html">Ogre::OGREWidget</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="interfaceOgreWindow.html">OgreWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1Operand.html">Ogre::RTShader::Operand</a></td><td class="indexvalue">A class that represents a function operand (its the combination of a parameter the in/out semantic and the used fields) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1OptimisedSubMeshGeometry.html">Ogre::StaticGeometry::OptimisedSubMeshGeometry</a></td><td class="indexvalue">Struct holding geometry optimised per <a class="el" href="classOgre_1_1SubMesh.html" title="Defines a part of a complete mesh.">SubMesh</a> / lod level, ready for copying to instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1InstancedGeometry_1_1OptimisedSubMeshGeometry.html">Ogre::InstancedGeometry::OptimisedSubMeshGeometry</a></td><td class="indexvalue">Struct holding geometry optimised per <a class="el" href="classOgre_1_1SubMesh.html" title="Defines a part of a complete mesh.">SubMesh</a> / lod level, ready for copying to instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OptimisedUtil.html">Ogre::OptimisedUtil</a></td><td class="indexvalue">Utility class for provides optimised functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXCarbonContext.html">Ogre::OSXCarbonContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXCarbonWindow.html">Ogre::OSXCarbonWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXCGLContext.html">Ogre::OSXCGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXCocoaContext.html">Ogre::OSXCocoaContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="interfaceOSXCocoaWindowDelegate.html">OSXCocoaWindowDelegate</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXContext.html">Ogre::OSXContext</a></td><td class="indexvalue">Class that encapsulates an GL context </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXGLSupport.html">Ogre::OSXGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXPBuffer.html">Ogre::OSXPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OSXWindow.html">Ogre::OSXWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Overlay.html">Ogre::Overlay</a></td><td class="indexvalue">Represents a layer which is rendered on top of the 'normal' scene contents </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayContainer.html">Ogre::OverlayContainer</a></td><td class="indexvalue">A 2D element which contains other <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElement.html">Ogre::OverlayElement</a></td><td class="indexvalue">Abstract definition of a 2D element to be displayed in an <a class="el" href="classOgre_1_1Overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents.">Overlay</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayElementFactory.html">Ogre::OverlayElementFactory</a></td><td class="indexvalue">Defines the interface which all components wishing to supply <a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> subclasses must implement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1OverlayManager.html">Ogre::OverlayManager</a></td><td class="indexvalue">Manages <a class="el" href="classOgre_1_1Overlay.html" title="Represents a layer which is rendered on top of the &#39;normal&#39; scene contents.">Overlay</a> objects, parsing them from .overlay files and storing a lookup library of them </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Page.html">Ogre::Page</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Page.html" title="Page class.">Page</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageContent.html">Ogre::PageContent</a></td><td class="indexvalue">Interface definition for a unit of content within a page </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageContentCollection.html">Ogre::PageContentCollection</a></td><td class="indexvalue">Definition of the interface for a collection of <a class="el" href="classOgre_1_1PageContent.html" title="Interface definition for a unit of content within a page.">PageContent</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageContentCollectionFactory.html">Ogre::PageContentCollectionFactory</a></td><td class="indexvalue">Define the interface to a factory class that will create subclasses of <a class="el" href="classOgre_1_1PageContentCollection.html" title="Definition of the interface for a collection of PageContent instances.">PageContentCollection</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageContentFactory.html">Ogre::PageContentFactory</a></td><td class="indexvalue">Define the interface to a factory class that will create subclasses of <a class="el" href="classOgre_1_1PageContent.html" title="Interface definition for a unit of content within a page.">PageContent</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Page_1_1PageData.html">Ogre::Page::PageData</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PagedWorld.html">Ogre::PagedWorld</a></td><td class="indexvalue">This class represents a collection of pages which make up a world </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PagedWorldSection.html">Ogre::PagedWorldSection</a></td><td class="indexvalue">Represents a section of the <a class="el" href="classOgre_1_1PagedWorld.html" title="This class represents a collection of pages which make up a world.">PagedWorld</a> which uses a given <a class="el" href="classOgre_1_1PageStrategy.html" title="Defines the interface to a strategy class which is responsible for deciding when Page instances are r...">PageStrategy</a>, and which is made up of a generally localised set of <a class="el" href="classOgre_1_1Page.html" title="Page class.">Page</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PagedWorldSectionFactory.html">Ogre::PagedWorldSectionFactory</a></td><td class="indexvalue">A factory class for creating types of world section </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageManager.html">Ogre::PageManager</a></td><td class="indexvalue">The <a class="el" href="classOgre_1_1PageManager.html" title="The PageManager is the entry point through which you load all PagedWorld instances, and the place where PageStrategy instances and factory classes are registered to customise the paging behaviour.">PageManager</a> is the entry point through which you load all <a class="el" href="classOgre_1_1PagedWorld.html" title="This class represents a collection of pages which make up a world.">PagedWorld</a> instances, and the place where <a class="el" href="classOgre_1_1PageStrategy.html" title="Defines the interface to a strategy class which is responsible for deciding when Page instances are r...">PageStrategy</a> instances and factory classes are registered to customise the paging behaviour </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageProvider.html">Ogre::PageProvider</a></td><td class="indexvalue">Abstract class that can be implemented by the user application to provide a way to retrieve or generate page data from a source of their choosing </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Page_1_1PageRequest.html">Ogre::Page::PageRequest</a></td><td class="indexvalue">Structure for holding background page requests </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Page_1_1PageResponse.html">Ogre::Page::PageResponse</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageStrategy.html">Ogre::PageStrategy</a></td><td class="indexvalue">Defines the interface to a strategy class which is responsible for deciding when <a class="el" href="classOgre_1_1Page.html" title="Page class.">Page</a> instances are requested for addition and removal from the paging system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PageStrategyData.html">Ogre::PageStrategyData</a></td><td class="indexvalue">Abstract marker class representing the data held against the <a class="el" href="classOgre_1_1PagedWorldSection.html" title="Represents a section of the PagedWorld which uses a given PageStrategy, and which is made up of a gen...">PagedWorldSection</a> which is specifically used by the <a class="el" href="classOgre_1_1PageStrategy.html" title="Defines the interface to a strategy class which is responsible for deciding when Page instances are r...">PageStrategy</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PanelOverlayElement.html">Ogre::PanelOverlayElement</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1OverlayElement.html" title="Abstract definition of a 2D element to be displayed in an Overlay.">OverlayElement</a> representing a flat, single-material (or transparent) panel which can contain other elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PanelOverlayElementFactory.html">Ogre::PanelOverlayElementFactory</a></td><td class="indexvalue">Factory for creating <a class="el" href="classOgre_1_1PanelOverlayElement.html" title="OverlayElement representing a flat, single-material (or transparent) panel which can contain other el...">PanelOverlayElement</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParamCommand.html">Ogre::ParamCommand</a></td><td class="indexvalue">Abstract class which is command object which gets/sets parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParamDictionary.html">Ogre::ParamDictionary</a></td><td class="indexvalue">Class to hold a dictionary of parameters for a single class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1Parameter.html">Ogre::RTShader::Parameter</a></td><td class="indexvalue">A class that represents a shader based program parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParameterDef.html">Ogre::ParameterDef</a></td><td class="indexvalue">Definition of a parameter supported by a <a class="el" href="classOgre_1_1StringInterface.html" title="Class defining the common interface which classes can use to present a reflection-style, self-defining parameter set to callers.">StringInterface</a> class, for introspection </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ParameterFactory.html">Ogre::RTShader::ParameterFactory</a></td><td class="indexvalue">Helper utility class that creates common parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Particle.html">Ogre::Particle</a></td><td class="indexvalue">Class representing a single particle instance </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleAffector.html">Ogre::ParticleAffector</a></td><td class="indexvalue">Abstract class defining the interface to be implemented by particle affectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleAffectorFactory.html">Ogre::ParticleAffectorFactory</a></td><td class="indexvalue">Abstract class defining the interface to be implemented by creators of <a class="el" href="classOgre_1_1ParticleAffector.html" title="Abstract class defining the interface to be implemented by particle affectors.">ParticleAffector</a> subclasses </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleAffectorTranslator.html">Ogre::ParticleAffectorTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleEmitter.html">Ogre::ParticleEmitter</a></td><td class="indexvalue">Abstract class defining the interface to be implemented by particle emitters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleEmitterFactory.html">Ogre::ParticleEmitterFactory</a></td><td class="indexvalue">Abstract class defining the interface to be implemented by creators of <a class="el" href="classOgre_1_1ParticleEmitter.html" title="Abstract class defining the interface to be implemented by particle emitters.">ParticleEmitter</a> subclasses </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleEmitterTranslator.html">Ogre::ParticleEmitterTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleIterator.html">Ogre::ParticleIterator</a></td><td class="indexvalue">Convenience class to make it easy to step through all particles in a <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleScriptCompiler.html">Ogre::ParticleScriptCompiler</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleScriptCompilerListener.html">Ogre::ParticleScriptCompilerListener</a></td><td class="indexvalue">This is the specific listener for the particle script compiler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystem.html">Ogre::ParticleSystem</a></td><td class="indexvalue">Class defining particle system based special effects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystemFactory.html">Ogre::ParticleSystemFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystemManager.html">Ogre::ParticleSystemManager</a></td><td class="indexvalue">Manages particle systems, particle system scripts (templates) and the available emitter &amp; affector factories </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystemRenderer.html">Ogre::ParticleSystemRenderer</a></td><td class="indexvalue">Abstract class defining the interface required to be implemented by classes which provide rendering capability to <a class="el" href="classOgre_1_1ParticleSystem.html" title="Class defining particle system based special effects.">ParticleSystem</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystemRendererFactory.html">Ogre::ParticleSystemRendererFactory</a></td><td class="indexvalue">Abstract class definition of a factory object for <a class="el" href="classOgre_1_1ParticleSystemRenderer.html" title="Abstract class defining the interface required to be implemented by classes which provide rendering c...">ParticleSystemRenderer</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleSystemTranslator.html">Ogre::ParticleSystemTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ParticleVisualData.html">Ogre::ParticleVisualData</a></td><td class="indexvalue">Abstract class containing any additional data required to be associated with a particle to perform the required rendering </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Pass.html">Ogre::Pass</a></td><td class="indexvalue">Class defining a single pass of a <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a> (of a <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a>), i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1QueuedRenderableCollection_1_1PassGroupLess.html">Ogre::QueuedRenderableCollection::PassGroupLess</a></td><td class="indexvalue">Comparator to order pass groups </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PassthroughControllerFunction.html">Ogre::PassthroughControllerFunction</a></td><td class="indexvalue">Predefined controller function which just passes through the original source directly to dest </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PassTranslator.html">Ogre::PassTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PatchMesh.html">Ogre::PatchMesh</a></td><td class="indexvalue">Patch specialisation of <a class="el" href="classOgre_1_1Mesh.html">Mesh</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PatchMeshPtr.html">Ogre::PatchMeshPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1PatchMeshPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to PatchMeshPtr.">PatchMeshPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PatchSurface.html">Ogre::PatchSurface</a></td><td class="indexvalue">A surface which is defined by curves of some kind to form a patch, e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESPBRTTManager_1_1PBRef.html">Ogre::GLESPBRTTManager::PBRef</a></td><td class="indexvalue">Reference to a PBuffer, with refcount </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLPBRTTManager_1_1PBRef.html">Ogre::GLPBRTTManager::PBRef</a></td><td class="indexvalue">Reference to a PBuffer, with refcount </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PixelBox.html">Ogre::PixelBox</a></td><td class="indexvalue">A primitive describing a volume (3D), image (2D) or line (1D) of pixels in memory </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PixelCountLodStrategy.html">Ogre::PixelCountLodStrategy</a></td><td class="indexvalue">Level of detail strategy based on pixel count approximation from bounding sphere projection </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PixelUtil.html">Ogre::PixelUtil</a></td><td class="indexvalue">Some utility functions for packing and unpacking pixel data </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Any_1_1placeholder.html">Ogre::Any::placeholder</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Plane.html">Ogre::Plane</a></td><td class="indexvalue">Defines a plane in 3D space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PlaneBoundedVolume.html">Ogre::PlaneBoundedVolume</a></td><td class="indexvalue">Represents a convex volume bounded by planes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PlaneBoundedVolumeListSceneQuery.html">Ogre::PlaneBoundedVolumeListSceneQuery</a></td><td class="indexvalue">Specialises the <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> class for querying within a plane-bounded volume </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PlaneOptimalShadowCameraSetup.html">Ogre::PlaneOptimalShadowCameraSetup</a></td><td class="indexvalue">Implements the plane optimal shadow camera algorithm </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PlatformInformation.html">Ogre::PlatformInformation</a></td><td class="indexvalue">Class which provides the run-time platform information <a class="el" href="namespaceOgre.html">Ogre</a> runs on </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Plugin.html">Ogre::Plugin</a></td><td class="indexvalue">Class defining a generic OGRE plugin </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProgressiveMesh_1_1PMFaceVertex.html">Ogre::ProgressiveMesh::PMFaceVertex</a></td><td class="indexvalue">A vertex as used by a face </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProgressiveMesh_1_1PMTriangle.html">Ogre::ProgressiveMesh::PMTriangle</a></td><td class="indexvalue">A triangle in the progressive mesh, holds extra info like face normal </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProgressiveMesh_1_1PMVertex.html">Ogre::ProgressiveMesh::PMVertex</a></td><td class="indexvalue">A vertex in the progressive mesh, holds info like collapse cost etc </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ProgressiveMesh_1_1PMWorkingData.html">Ogre::ProgressiveMesh::PMWorkingData</a></td><td class="indexvalue">Data used to calculate the collapse costs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1FocusedShadowCameraSetup_1_1PointListBody.html">Ogre::FocusedShadowCameraSetup::PointListBody</a></td><td class="indexvalue">Internal class holding a point list representation of a convex body </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Polygon.html">Ogre::Polygon</a></td><td class="indexvalue">The class represents a polygon in 3D space </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Pool.html">Ogre::Pool&lt; T &gt;</a></td><td class="indexvalue">Template class describing a simple pool of items </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Pose.html">Ogre::Pose</a></td><td class="indexvalue">A pose is a linked set of vertex offsets applying to one set of vertex data </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1VertexPoseKeyFrame_1_1PoseRef.html">Ogre::VertexPoseKeyFrame::PoseRef</a></td><td class="indexvalue">Reference to a pose at a given influence level </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PreApplyTextureAliasesScriptCompilerEvent.html">Ogre::PreApplyTextureAliasesScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PrefabFactory.html">Ogre::PrefabFactory</a></td><td class="indexvalue">A factory class that can create various mesh prefabs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProcessNameExclusionScriptCompilerEvent.html">Ogre::ProcessNameExclusionScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProcessResourceNameScriptCompilerEvent.html">Ogre::ProcessResourceNameScriptCompilerEvent</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGenerator_1_1Profile.html">Ogre::TerrainMaterialGenerator::Profile</a></td><td class="indexvalue">Inner class which should also be subclassed to provide profile-specific material generation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Profile.html">Ogre::Profile</a></td><td class="indexvalue">An individual profile that will be processed by the <a class="el" href="classOgre_1_1Profiler.html" title="The profiler allows you to measure the performance of your code.">Profiler</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Profiler_1_1ProfileFrame.html">Ogre::Profiler::ProfileFrame</a></td><td class="indexvalue">Represents the total timing information of a profile since profiles can be called more than once each frame </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Profiler_1_1ProfileHistory.html">Ogre::Profiler::ProfileHistory</a></td><td class="indexvalue">Represents a history of each profile during the duration of the app </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Profiler_1_1ProfileInstance.html">Ogre::Profiler::ProfileInstance</a></td><td class="indexvalue">Represents an individual profile call </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Profiler.html">Ogre::Profiler</a></td><td class="indexvalue">The profiler allows you to measure the performance of your code </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1Program.html">Ogre::RTShader::Program</a></td><td class="indexvalue">A class that represents a shader based program </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramManager.html">Ogre::RTShader::ProgramManager</a></td><td class="indexvalue">A singleton manager class that manages shader based programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramProcessor.html">Ogre::RTShader::ProgramProcessor</a></td><td class="indexvalue">A class that provides extra processing services on CPU based programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramSet.html">Ogre::RTShader::ProgramSet</a></td><td class="indexvalue">Container class for shader based programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramWriter.html">Ogre::RTShader::ProgramWriter</a></td><td class="indexvalue">Base class interface for shader program writers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramWriterFactory.html">Ogre::RTShader::ProgramWriterFactory</a></td><td class="indexvalue">Interface definition for factories of ShaderProgramWriter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ProgramWriterManager.html">Ogre::RTShader::ProgramWriterManager</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ProgressiveMesh.html">Ogre::ProgressiveMesh</a></td><td class="indexvalue">This class reduces the complexity of the geometry it is given </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Property.html">Ogre::Property&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Property.html" title="Property instance with passthrough calls to a given object.">Property</a> instance with passthrough calls to a given object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PropertyAbstractNode.html">Ogre::PropertyAbstractNode</a></td><td class="indexvalue">This abstract node represents a script property </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PropertyBase.html">Ogre::PropertyBase</a></td><td class="indexvalue">Base interface for an instance of a property </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PropertyDef.html">Ogre::PropertyDef</a></td><td class="indexvalue">Definition of a property of an object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PropertySet.html">Ogre::PropertySet</a></td><td class="indexvalue">Defines a complete set of properties for a single object instance </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1PropertyValue.html">Ogre::PropertyValue</a></td><td class="indexvalue">A simple structure designed just as a holder of property values between the instances of objects they might target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PSSMShadowCameraSetup.html">Ogre::PSSMShadowCameraSetup</a></td><td class="indexvalue">Parallel Split Shadow Map (PSSM) shadow camera setup </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1PVRTCCodec.html">Ogre::PVRTCCodec</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Codec.html" title="Abstract class that defines a &#39;codec&#39;.">Codec</a> specialized in loading PVRTC (PowerVR) images </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Quaternion.html">Ogre::Quaternion</a></td><td class="indexvalue">Implementation of a <a class="el" href="classOgre_1_1Quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a>, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1StaticGeometry_1_1QueuedGeometry.html">Ogre::StaticGeometry::QueuedGeometry</a></td><td class="indexvalue">Structure recording a queued geometry for low level builds </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1InstancedGeometry_1_1QueuedGeometry.html">Ogre::InstancedGeometry::QueuedGeometry</a></td><td class="indexvalue">Structure recording a queued geometry for low level builds </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1QueuedRenderableCollection.html">Ogre::QueuedRenderableCollection</a></td><td class="indexvalue">Lowest level collection of renderables </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1QueuedRenderableVisitor.html">Ogre::QueuedRenderableVisitor</a></td><td class="indexvalue">Visitor interface for items in a <a class="el" href="classOgre_1_1QueuedRenderableCollection.html" title="Lowest level collection of renderables.">QueuedRenderableCollection</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1StaticGeometry_1_1QueuedSubMesh.html">Ogre::StaticGeometry::QueuedSubMesh</a></td><td class="indexvalue">Structure recording a queued submesh for the build </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1InstancedGeometry_1_1QueuedSubMesh.html">Ogre::InstancedGeometry::QueuedSubMesh</a></td><td class="indexvalue">Structure recording a queued submesh for the build </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Radian.html">Ogre::Radian</a></td><td class="indexvalue">Wrapper class which indicates a given angle value is in Radians </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RadixSort.html">Ogre::RadixSort&lt; TContainer, TContainerValueType, TCompValueType &gt;</a></td><td class="indexvalue">Class for performing a radix sort (fast comparison-less sort based on byte value) on various standard STL containers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1QueuedRenderableCollection_1_1RadixSortFunctorDistance.html">Ogre::QueuedRenderableCollection::RadixSortFunctorDistance</a></td><td class="indexvalue">Functor for descending sort value 2 for radix sort (distance) </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1QueuedRenderableCollection_1_1RadixSortFunctorPass.html">Ogre::QueuedRenderableCollection::RadixSortFunctorPass</a></td><td class="indexvalue">Functor for accessing sort value 1 for radix sort (<a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a>) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Ray.html">Ogre::Ray</a></td><td class="indexvalue">Representation of a ray in space, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainGroup_1_1RayResult.html">Ogre::TerrainGroup::RayResult</a></td><td class="indexvalue">Result from a terrain ray intersection with the terrain group </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RaySceneQuery.html">Ogre::RaySceneQuery</a></td><td class="indexvalue">Specialises the <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> class for querying along a ray </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RaySceneQueryListener.html">Ogre::RaySceneQueryListener</a></td><td class="indexvalue">Alternative listener class for dealing with <a class="el" href="classOgre_1_1RaySceneQuery.html" title="Specialises the SceneQuery class for querying along a ray.">RaySceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RaySceneQueryResultEntry.html">Ogre::RaySceneQueryResultEntry</a></td><td class="indexvalue">This struct allows a single comparison of result data no matter what the type </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLFBOManager_1_1RBFormat.html">Ogre::GLFBOManager::RBFormat</a></td><td class="indexvalue">Stencil and depth renderbuffers of the same format are re-used between surfaces of the same size and format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLES2FBOManager_1_1RBFormat.html">Ogre::GLES2FBOManager::RBFormat</a></td><td class="indexvalue">Stencil and depth renderbuffers of the same format are re-used between surfaces of the same size and format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESFBOManager_1_1RBFormat.html">Ogre::GLESFBOManager::RBFormat</a></td><td class="indexvalue">Stencil and depth renderbuffers of the same format are re-used between surfaces of the same size and format </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLES2FBOManager_1_1RBRef.html">Ogre::GLES2FBOManager::RBRef</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLESFBOManager_1_1RBRef.html">Ogre::GLESFBOManager::RBRef</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1GLFBOManager_1_1RBRef.html">Ogre::GLFBOManager::RBRef</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1STLAllocator_1_1rebind.html">Ogre::STLAllocator&lt; T, AllocPolicy &gt;::rebind&lt; U &gt;</a></td><td class="indexvalue">Standard rebind mechanism </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1Rectangle.html">Ogre::Rectangle</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Rectangle2D.html">Ogre::Rectangle2D</a></td><td class="indexvalue">Allows the rendering of a simple 2D rectangle This class renders a simple 2D rectangle; this rectangle has no depth and therefore is best used with specific render queue and depth settings, like RENDER_QUEUE_BACKGROUND and 'depth_write off' for backdrops, and RENDER_QUEUE_OVERLAY and 'depth_check off' for fullscreen quads </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry_1_1Region.html">Ogre::StaticGeometry::Region</a></td><td class="indexvalue">The details of a topological region which is the highest level of partitioning for this class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RegionSceneQuery.html">Ogre::RegionSceneQuery</a></td><td class="indexvalue">Abstract class defining a query which returns single results from a region </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainQuadTreeNode_1_1Rend.html">Ogre::TerrainQuadTreeNode::Rend</a></td><td class="indexvalue">Hook to the render queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Renderable.html">Ogre::Renderable</a></td><td class="indexvalue">Abstract class defining the interface all renderable objects must implement </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderableListener.html">Ogre::RenderQueue::RenderableListener</a></td><td class="indexvalue">Class to listen in on items being added to the render queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderablePass.html">Ogre::RenderablePass</a></td><td class="indexvalue">Struct associating a single <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> with a single <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1RenderContext.html">Ogre::SceneManager::RenderContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderingAPIException.html">Ogre::RenderingAPIException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderObjectListener.html">Ogre::RenderObjectListener</a></td><td class="indexvalue">Abstract interface which classes must implement if they wish to receive events from the scene manager when single object is about to be rendered </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderOperation.html">Ogre::RenderOperation</a></td><td class="indexvalue">'New' rendering operation using vertex buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderPriorityGroup.html">Ogre::RenderPriorityGroup</a></td><td class="indexvalue">Collection of renderables by priority </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueue.html">Ogre::RenderQueue</a></td><td class="indexvalue">Class to manage the scene object rendering queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueueGroup.html">Ogre::RenderQueueGroup</a></td><td class="indexvalue">A grouping level underneath <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> which groups renderables to be issued at coarsely the same time to the renderer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderQueueGroupMap.html">Ogre::RenderQueue::RenderQueueGroupMap</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueueInvocation.html">Ogre::RenderQueueInvocation</a></td><td class="indexvalue">Class representing the invocation of queue groups in a <a class="el" href="classOgre_1_1RenderQueue.html" title="Class to manage the scene object rendering queue.">RenderQueue</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueueInvocationSequence.html">Ogre::RenderQueueInvocationSequence</a></td><td class="indexvalue">Class to hold a linear sequence of <a class="el" href="classOgre_1_1RenderQueueInvocation.html" title="Class representing the invocation of queue groups in a RenderQueue.">RenderQueueInvocation</a> objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueueListener.html">Ogre::RenderQueueListener</a></td><td class="indexvalue">Abstract interface which classes must implement if they wish to receive events from the render queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1RenderState.html">Ogre::RTShader::RenderState</a></td><td class="indexvalue">This is a container class for sub render state class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderSystem.html">Ogre::RenderSystem</a></td><td class="indexvalue">Defines the functionality of a 3D API </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderSystemCapabilities.html">Ogre::RenderSystemCapabilities</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Singleton.html" title="Template class for creating single-instance global classes.">Singleton</a> class for storing the capabilities of the graphics card </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderSystemCapabilitiesManager.html">Ogre::RenderSystemCapabilitiesManager</a></td><td class="indexvalue">Class for managing <a class="el" href="classOgre_1_1RenderSystemCapabilities.html" title="singleton class for storing the capabilities of the graphics card.">RenderSystemCapabilities</a> database for <a class="el" href="namespaceOgre.html">Ogre</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderSystemCapabilitiesSerializer.html">Ogre::RenderSystemCapabilitiesSerializer</a></td><td class="indexvalue">Class for serializing <a class="el" href="classOgre_1_1RenderSystemCapabilities.html" title="singleton class for storing the capabilities of the graphics card.">RenderSystemCapabilities</a> to / from a .rendercaps script </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderSystem_1_1RenderSystemContext.html">Ogre::RenderSystem::RenderSystemContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Renderable_1_1RenderSystemData.html">Ogre::Renderable::RenderSystemData</a></td><td class="indexvalue">An internal class that should be used only by a render system for internal use </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorInstance_1_1RenderSystemOperation.html">Ogre::CompositorInstance::RenderSystemOperation</a></td><td class="indexvalue">Specific render system operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderTarget.html">Ogre::RenderTarget</a></td><td class="indexvalue">A 'canvas' which can receive the results of a rendering operation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderTargetEvent.html">Ogre::RenderTargetEvent</a></td><td class="indexvalue">Struct containing information about a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> event </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderTargetListener.html">Ogre::RenderTargetListener</a></td><td class="indexvalue">A interface class defining a listener which can be used to receive notifications of <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> events </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderTargetViewportEvent.html">Ogre::RenderTargetViewportEvent</a></td><td class="indexvalue">Struct containing information about a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> Viewport-specific event </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderTexture.html">Ogre::RenderTexture</a></td><td class="indexvalue">This class represents a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> that renders to a <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderToVertexBuffer.html">Ogre::RenderToVertexBuffer</a></td><td class="indexvalue">An object which renders geometry to a vertex </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderWindow.html">Ogre::RenderWindow</a></td><td class="indexvalue">Manages the target rendering window </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RenderWindowDescription.html">Ogre::RenderWindowDescription</a></td><td class="indexvalue">Render window creation parameters </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9Device_1_1RenderWindowResources.html">Ogre::D3D9Device::RenderWindowResources</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WorkQueue_1_1Request.html">Ogre::WorkQueue::Request</a></td><td class="indexvalue">General purpose request structure </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WorkQueue_1_1RequestHandler.html">Ogre::WorkQueue::RequestHandler</a></td><td class="indexvalue">Interface definition for a handler of requests </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1DefaultWorkQueueBase_1_1RequestHandlerHolder.html">Ogre::DefaultWorkQueueBase::RequestHandlerHolder</a></td><td class="indexvalue">Intermediate structure to hold a pointer to a request handler which provides insurance against the handler itself being disconnected while the list remains unchanged </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Resource.html">Ogre::Resource</a></td><td class="indexvalue">Abstract class representing a loadable resource (e.g </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceBackgroundQueue.html">Ogre::ResourceBackgroundQueue</a></td><td class="indexvalue">This class is used to perform <a class="el" href="classOgre_1_1Resource.html" title="Abstract class representing a loadable resource (e.g.">Resource</a> operations in a background thread </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ResourceGroupManager_1_1ResourceDeclaration.html">Ogre::ResourceGroupManager::ResourceDeclaration</a></td><td class="indexvalue">Nested struct defining a resource declaration </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ResourceGroupManager_1_1ResourceGroup.html">Ogre::ResourceGroupManager::ResourceGroup</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Resource.html" title="Abstract class representing a loadable resource (e.g.">Resource</a> group entry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceGroupListener.html">Ogre::ResourceGroupListener</a></td><td class="indexvalue">This abstract class defines an interface which is called back during resource group loading to indicate the progress of the load </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceGroupManager.html">Ogre::ResourceGroupManager</a></td><td class="indexvalue">This singleton class manages the list of resource groups, and notifying the various resource managers of their obligations to load / unload resources in a group </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceLoadingListener.html">Ogre::ResourceLoadingListener</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ResourceGroupManager_1_1ResourceLocation.html">Ogre::ResourceGroupManager::ResourceLocation</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Resource.html" title="Abstract class representing a loadable resource (e.g.">Resource</a> location entry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceManager.html">Ogre::ResourceManager</a></td><td class="indexvalue">Defines a generic resource handler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ResourceManager_1_1ResourcePool.html">Ogre::ResourceManager::ResourcePool</a></td><td class="indexvalue">Definition of a pool of resources, which users can use to reuse similar resources many times without destroying and recreating them </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ResourceBackgroundQueue_1_1ResourceRequest.html">Ogre::ResourceBackgroundQueue::ResourceRequest</a></td><td class="indexvalue">Encapsulates a queued request for the background queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ResourceBackgroundQueue_1_1ResourceResponse.html">Ogre::ResourceBackgroundQueue::ResourceResponse</a></td><td class="indexvalue">Struct that holds details of queued notifications </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1WorkQueue_1_1Response.html">Ogre::WorkQueue::Response</a></td><td class="indexvalue">General purpose response structure </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WorkQueue_1_1ResponseHandler.html">Ogre::WorkQueue::ResponseHandler</a></td><td class="indexvalue">Interface definition for a handler of responses </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TangentSpaceCalc_1_1Result.html">Ogre::TangentSpaceCalc::Result</a></td><td class="indexvalue">The result of having built a tangent space basis </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RibbonTrail.html">Ogre::RibbonTrail</a></td><td class="indexvalue">Subclass of <a class="el" href="classOgre_1_1BillboardChain.html" title="Allows the rendering of a chain of connected billboards.">BillboardChain</a> which automatically leaves a trail behind one or more <a class="el" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RibbonTrailFactory.html">Ogre::RibbonTrailFactory</a></td><td class="indexvalue">Factory object for creating <a class="el" href="classOgre_1_1RibbonTrail.html" title="Subclass of BillboardChain which automatically leaves a trail behind one or more Node instances...">RibbonTrail</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Root.html">Ogre::Root</a></td><td class="indexvalue">The root class of the <a class="el" href="namespaceOgre.html">Ogre</a> system </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RotationalSpline.html">Ogre::RotationalSpline</a></td><td class="indexvalue">This class interpolates orientations (rotations) along a spline using derivatives of quaternions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorChain_1_1RQListener.html">Ogre::CompositorChain::RQListener</a></td><td class="indexvalue">Render queue listener used to set up rendering events </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RuntimeAssertionException.html">Ogre::RuntimeAssertionException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScaleControllerFunction.html">Ogre::ScaleControllerFunction</a></td><td class="indexvalue">Predefined controller function which simply scales an input to an output value </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManager.html">Ogre::SceneManager</a></td><td class="indexvalue">Manages the organisation and rendering of a 'scene' i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManagerEnumerator.html">Ogre::SceneManagerEnumerator</a></td><td class="indexvalue">Enumerates the <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> classes available to applications </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManagerFactory.html">Ogre::SceneManagerFactory</a></td><td class="indexvalue">Class which will create instances of a given <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManagerMetaData.html">Ogre::SceneManagerMetaData</a></td><td class="indexvalue">Structure containing information about a scene manager </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManager_1_1SceneMgrQueuedRenderableVisitor.html">Ogre::SceneManager::SceneMgrQueuedRenderableVisitor</a></td><td class="indexvalue">Inner helper class to implement the visitor pattern for rendering objects in a queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneNode.html">Ogre::SceneNode</a></td><td class="indexvalue">Class representing a node in the scene graph </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneQuery.html">Ogre::SceneQuery</a></td><td class="indexvalue">A class for performing queries on a scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneQueryListener.html">Ogre::SceneQueryListener</a></td><td class="indexvalue">This optional class allows you to receive per-result callbacks from <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> executions instead of a single set of consolidated results </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneQueryResult.html">Ogre::SceneQueryResult</a></td><td class="indexvalue">Holds the results of a scene query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptCompiler.html">Ogre::ScriptCompiler</a></td><td class="indexvalue">This is the main class for the compiler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptCompilerEvent.html">Ogre::ScriptCompilerEvent</a></td><td class="indexvalue">This struct is a base class for events which can be thrown by the compilers and caught by subscribers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptCompilerListener.html">Ogre::ScriptCompilerListener</a></td><td class="indexvalue">This is a listener for the compiler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptCompilerManager.html">Ogre::ScriptCompilerManager</a></td><td class="indexvalue">Manages threaded compilation of scripts </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptLexer.html">Ogre::ScriptLexer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptLoader.html">Ogre::ScriptLoader</a></td><td class="indexvalue">Abstract class defining the interface used by classes which wish to perform script loading to define instances of whatever they manage </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptParser.html">Ogre::ScriptParser</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ScriptToken.html">Ogre::ScriptToken</a></td><td class="indexvalue">This struct represents a token, which is an ID'd lexeme from the parsing input stream </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptTranslator.html">Ogre::ScriptTranslator</a></td><td class="indexvalue">This class translates script AST (abstract syntax tree) into <a class="el" href="namespaceOgre.html">Ogre</a> resources </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ScriptTranslatorManager.html">Ogre::ScriptTranslatorManager</a></td><td class="indexvalue">The <a class="el" href="classOgre_1_1ScriptTranslatorManager.html" title="The ScriptTranslatorManager manages the lifetime and access to script translators.">ScriptTranslatorManager</a> manages the lifetime and access to script translators </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D11RenderSystem_1_1sD3DTextureStageDesc.html">Ogre::D3D11RenderSystem::sD3DTextureStageDesc</a></td><td class="indexvalue">Structure holding texture unit settings for every stage </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9RenderSystem_1_1sD3DTextureStageDesc.html">Ogre::D3D9RenderSystem::sD3DTextureStageDesc</a></td><td class="indexvalue">Structure holding texture unit settings for every stage </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SDLGLSupport.html">Ogre::SDLGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SDLWindow.html">Ogre::SDLWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainPaging_1_1SectionFactory.html">Ogre::TerrainPaging::SectionFactory</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Serializer.html">Ogre::Serializer</a></td><td class="indexvalue">Generic class for serialising data to / from binary stream-based files </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1set.html">Ogre::set&lt; T, P, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGMaterial.html">Ogre::RTShader::ShaderGenerator::SGMaterial</a></td><td class="indexvalue">Shader generator material wrapper class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1SGMaterialSerializerListener.html">Ogre::RTShader::SGMaterialSerializerListener</a></td><td class="indexvalue">This class responsible for translating core features of the RT Shader System for <a class="el" href="namespaceOgre.html">Ogre</a> material scripts </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGPass.html">Ogre::RTShader::ShaderGenerator::SGPass</a></td><td class="indexvalue">Shader generator pass wrapper class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGRenderObjectListener.html">Ogre::RTShader::ShaderGenerator::SGRenderObjectListener</a></td><td class="indexvalue">Shader generator <a class="el" href="classOgre_1_1RenderObjectListener.html" title="Abstract interface which classes must implement if they wish to receive events from the scene manager...">RenderObjectListener</a> sub class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGSceneManagerListener.html">Ogre::RTShader::ShaderGenerator::SGSceneManagerListener</a></td><td class="indexvalue">Shader generator scene manager sub class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGScheme.html">Ogre::RTShader::ShaderGenerator::SGScheme</a></td><td class="indexvalue">Shader generator scheme class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1SGScriptTranslator.html">Ogre::RTShader::SGScriptTranslator</a></td><td class="indexvalue">This class responsible for translating core features of the RT Shader System for <a class="el" href="namespaceOgre.html">Ogre</a> material scripts </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGScriptTranslatorManager.html">Ogre::RTShader::ShaderGenerator::SGScriptTranslatorManager</a></td><td class="indexvalue">Shader generator <a class="el" href="classOgre_1_1ScriptTranslatorManager.html" title="The ScriptTranslatorManager manages the lifetime and access to script translators.">ScriptTranslatorManager</a> sub class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator_1_1SGTechnique.html">Ogre::RTShader::ShaderGenerator::SGTechnique</a></td><td class="indexvalue">Shader generator technique wrapper class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderGenerator.html">Ogre::RTShader::ShaderGenerator</a></td><td class="indexvalue">Shader generator system main interface </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile_1_1ShaderHelper.html">Ogre::TerrainMaterialGeneratorA::SM2Profile::ShaderHelper</a></td><td class="indexvalue">Interface definition for helper class to generate shaders </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile_1_1ShaderHelperCg.html">Ogre::TerrainMaterialGeneratorA::SM2Profile::ShaderHelperCg</a></td><td class="indexvalue">Utility class to help with generating shaders for Cg / HLSL </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile_1_1ShaderHelperGLSL.html">Ogre::TerrainMaterialGeneratorA::SM2Profile::ShaderHelperGLSL</a></td><td class="indexvalue">Utility class to help with generating shaders for GLSL </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile_1_1ShaderHelperGLSLES.html">Ogre::TerrainMaterialGeneratorA::SM2Profile::ShaderHelperGLSLES</a></td><td class="indexvalue">Utility class to help with generating shaders for GLSL ES </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile_1_1ShaderHelperHLSL.html">Ogre::TerrainMaterialGeneratorA::SM2Profile::ShaderHelperHLSL</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderProgramWriterCGFactory.html">Ogre::RTShader::ShaderProgramWriterCGFactory</a></td><td class="indexvalue">CG program writer factory implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderProgramWriterGLSLESFactory.html">Ogre::RTShader::ShaderProgramWriterGLSLESFactory</a></td><td class="indexvalue">GLSL ES program writer factory implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderProgramWriterGLSLFactory.html">Ogre::RTShader::ShaderProgramWriterGLSLFactory</a></td><td class="indexvalue">GLSL program writer factory implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1ShaderProgramWriterHLSLFactory.html">Ogre::RTShader::ShaderProgramWriterHLSLFactory</a></td><td class="indexvalue">HLSL program writer factory implementation </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D11HLSLProgram_1_1ShaderVarWithPosInBuf.html">Ogre::D3D11HLSLProgram::ShaderVarWithPosInBuf</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ShadowCameraSetup.html">Ogre::ShadowCameraSetup</a></td><td class="indexvalue">This class allows you to plug in new ways to define the camera setup when rendering and projecting shadow textures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ShadowCaster.html">Ogre::ShadowCaster</a></td><td class="indexvalue">This class defines the interface that must be implemented by shadow casters </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SceneManager_1_1ShadowCasterSceneQueryListener.html">Ogre::SceneManager::ShadowCasterSceneQueryListener</a></td><td class="indexvalue">Inner class to use as callback for shadow caster scene query </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ShadowRenderable.html">Ogre::ShadowRenderable</a></td><td class="indexvalue">Class which represents the renderable aspects of a set of shadow volume faces </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ShadowTextureConfig.html">Ogre::ShadowTextureConfig</a></td><td class="indexvalue">Structure containing the configuration for one shadow texture </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ShadowTextureManager.html">Ogre::ShadowTextureManager</a></td><td class="indexvalue">Class to manage the available shadow textures which may be shared between many <a class="el" href="classOgre_1_1SceneManager.html" title="Manages the organisation and rendering of a &#39;scene&#39; i.e.">SceneManager</a> instances if formats agree </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ShadowVolumeExtrudeProgram.html">Ogre::ShadowVolumeExtrudeProgram</a></td><td class="indexvalue">Static class containing source for vertex programs for extruding shadow volumes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SharedParamsTranslator.html">Ogre::SharedParamsTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SharedPtr.html">Ogre::SharedPtr&lt; T &gt;</a></td><td class="indexvalue">Reference-counted shared pointer, used for objects where implicit destruction is required </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SimplePageContentCollection.html">Ogre::SimplePageContentCollection</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1PageContentCollection.html" title="Definition of the interface for a collection of PageContent instances.">PageContentCollection</a> which just provides a simple list of <a class="el" href="classOgre_1_1PageContent.html" title="Interface definition for a unit of content within a page.">PageContent</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SimplePageContentCollectionFactory.html">Ogre::SimplePageContentCollectionFactory</a></td><td class="indexvalue">Factory class for <a class="el" href="classOgre_1_1SimplePageContentCollection.html" title="Specialisation of PageContentCollection which just provides a simple list of PageContent instances...">SimplePageContentCollection</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SimpleRenderable.html">Ogre::SimpleRenderable</a></td><td class="indexvalue">Simple implementation of <a class="el" href="classOgre_1_1MovableObject.html" title="Abstract class defining a movable object in a scene.">MovableObject</a> and <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> for single-part custom objects </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SimpleSpline.html">Ogre::SimpleSpline</a></td><td class="indexvalue">A very simple spline class which implements the Catmull-Rom class of splines </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Singleton.html">Ogre::Singleton&lt; T &gt;</a></td><td class="indexvalue">Template class for creating single-instance global classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Skeleton.html">Ogre::Skeleton</a></td><td class="indexvalue">A collection of <a class="el" href="classOgre_1_1Bone.html" title="A bone in a skeleton.">Bone</a> objects used to animate a skinned mesh </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SkeletonInstance.html">Ogre::SkeletonInstance</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1SkeletonInstance.html" title="A SkeletonInstance is a single instance of a Skeleton used by a world object.">SkeletonInstance</a> is a single instance of a <a class="el" href="classOgre_1_1Skeleton.html" title="A collection of Bone objects used to animate a skinned mesh.">Skeleton</a> used by a world object </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SkeletonManager.html">Ogre::SkeletonManager</a></td><td class="indexvalue">Handles the management of skeleton resources </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SkeletonPtr.html">Ogre::SkeletonPtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1SkeletonPtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to SkeletonPtr.">SkeletonPtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SkeletonSerializer.html">Ogre::SkeletonSerializer</a></td><td class="indexvalue">Class for serialising skeleton data to/from an OGRE .skeleton file </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1SkyBoxGenParameters.html">Ogre::SceneManager::SkyBoxGenParameters</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1SkyDomeGenParameters.html">Ogre::SceneManager::SkyDomeGenParameters</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneManager_1_1SkyPlaneGenParameters.html">Ogre::SceneManager::SkyPlaneGenParameters</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA_1_1SM2Profile.html">Ogre::TerrainMaterialGeneratorA::SM2Profile</a></td><td class="indexvalue">Shader model 2 profile target </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVector.html">Ogre::SmallVector&lt; T, N &gt;</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1SmallVector.html" title="SmallVector - This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the ar...">SmallVector</a> - This is a 'vector' (really, a variable-sized array), optimized for the case when the array is small </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVector_3_01T_00_010_01_4.html">Ogre::SmallVector&lt; T, 0 &gt;</a></td><td class="indexvalue">Specialize <a class="el" href="classOgre_1_1SmallVector.html" title="SmallVector - This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the ar...">SmallVector</a> at N=0 </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVectorBase.html">Ogre::SmallVectorBase</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1SmallVectorBase.html" title="SmallVectorBase - This is all the non-templated stuff common to all SmallVectors.">SmallVectorBase</a> - This is all the non-templated stuff common to all SmallVectors </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVectorImpl.html">Ogre::SmallVectorImpl&lt; T &gt;</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1SmallVectorImpl.html" title="SmallVectorImpl - This class consists of common code factored out of the SmallVector class to reduce ...">SmallVectorImpl</a> - This class consists of common code factored out of the <a class="el" href="classOgre_1_1SmallVector.html" title="SmallVector - This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the ar...">SmallVector</a> class to reduce code duplication based on the <a class="el" href="classOgre_1_1SmallVector.html" title="SmallVector - This is a &#39;vector&#39; (really, a variable-sized array), optimized for the case when the ar...">SmallVector</a> 'N' template parameter </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVectorTemplateBase.html">Ogre::SmallVectorTemplateBase&lt; T, isPodLike &gt;</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1SmallVectorTemplateBase.html" title="SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where we put method implementations that are desig...">SmallVectorTemplateBase</a>&lt;<a class="el" href="structOgre_1_1isPodLike.html">isPodLike</a> = false&gt; - This is where we put method implementations that are designed to work with non-POD-like T's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVectorTemplateBase_3_01T_00_01true_01_4.html">Ogre::SmallVectorTemplateBase&lt; T, true &gt;</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1SmallVectorTemplateBase.html" title="SmallVectorTemplateBase&lt;isPodLike = false&gt; - This is where we put method implementations that are desig...">SmallVectorTemplateBase</a>&lt;<a class="el" href="structOgre_1_1isPodLike.html">isPodLike</a> = true&gt; - This is where we put method implementations that are designed to work with POD-like T's </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SmallVectorTemplateCommon.html">Ogre::SmallVectorTemplateCommon&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ParticleSystem_1_1SortByDirectionFunctor.html">Ogre::ParticleSystem::SortByDirectionFunctor</a></td><td class="indexvalue">Sort by direction functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1BillboardSet_1_1SortByDirectionFunctor.html">Ogre::BillboardSet::SortByDirectionFunctor</a></td><td class="indexvalue">Sort by direction functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ParticleSystem_1_1SortByDistanceFunctor.html">Ogre::ParticleSystem::SortByDistanceFunctor</a></td><td class="indexvalue">Sort by distance functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1BillboardSet_1_1SortByDistanceFunctor.html">Ogre::BillboardSet::SortByDistanceFunctor</a></td><td class="indexvalue">Sort by distance functor </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1RadixSort_1_1SortEntry.html">Ogre::RadixSort&lt; TContainer, TContainerValueType, TCompValueType &gt;::SortEntry</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Sphere.html">Ogre::Sphere</a></td><td class="indexvalue">A sphere primitive, mostly used for bounds checking </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SphereSceneQuery.html">Ogre::SphereSceneQuery</a></td><td class="indexvalue">Specialises the <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> class for querying within a sphere </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1NodeAnimationTrack_1_1Splines.html">Ogre::NodeAnimationTrack::Splines</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticCache.html">Ogre::StaticCache&lt; cacheSize &gt;</a></td><td class="indexvalue">Template version of cache based on static array </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1StaticFaceGroup.html">Ogre::StaticFaceGroup</a></td><td class="indexvalue">Collects a group of static i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StaticGeometry.html">Ogre::StaticGeometry</a></td><td class="indexvalue">Pre-transforms and batches up meshes for efficient use as static geometry in a scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StdAlignedAllocPolicy.html">Ogre::StdAlignedAllocPolicy&lt; Alignment &gt;</a></td><td class="indexvalue">A "standard" allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a>, which aligns memory at a given boundary (which should be a power of 2) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StdAllocPolicy.html">Ogre::StdAllocPolicy</a></td><td class="indexvalue">A "standard" allocation policy for use with <a class="el" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">AllocatedObject</a> and <a class="el" href="classOgre_1_1STLAllocator.html">STLAllocator</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1STLAllocator.html">Ogre::STLAllocator&lt; T, AllocPolicy &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1STLAllocatorBase.html">Ogre::STLAllocatorBase&lt; T &gt;</a></td><td class="indexvalue">Wrapper class for operating as an STL container allocator </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1STLAllocatorBase_3_01const_01T_01_4.html">Ogre::STLAllocatorBase&lt; const T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Log_1_1Stream.html">Ogre::Log::Stream</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Log_1_1Stream.html" title="Stream object which targets a log.">Stream</a> object which targets a log </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StreamSerialiser.html">Ogre::StreamSerialiser</a></td><td class="indexvalue">Utility class providing helper methods for reading / writing structured data held in a <a class="el" href="classOgre_1_1DataStream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StringConverter.html">Ogre::StringConverter</a></td><td class="indexvalue">Class for converting the core <a class="el" href="namespaceOgre.html">Ogre</a> data types to/from Strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StringInterface.html">Ogre::StringInterface</a></td><td class="indexvalue">Class defining the common interface which classes can use to present a reflection-style, self-defining parameter set to callers </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StringSerialiser.html">Ogre::StringSerialiser</a></td><td class="indexvalue">Serializes data values into a string using sprintf functions </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1StringUtil.html">Ogre::StringUtil</a></td><td class="indexvalue">Utility class for manipulating Strings </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SubEntity.html">Ogre::SubEntity</a></td><td class="indexvalue">Utility class which defines the sub-parts of an <a class="el" href="classOgre_1_1Entity.html" title="Defines an instance of a discrete, movable object based on a Mesh.">Entity</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1SubMesh.html">Ogre::SubMesh</a></td><td class="indexvalue">Defines a part of a complete mesh </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1StaticGeometry_1_1SubMeshLodGeometryLink.html">Ogre::StaticGeometry::SubMeshLodGeometryLink</a></td><td class="indexvalue">Saved link between <a class="el" href="classOgre_1_1SubMesh.html" title="Defines a part of a complete mesh.">SubMesh</a> at a LOD and vertex/index data May point to original or optimised geometry </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1InstancedGeometry_1_1SubMeshLodGeometryLink.html">Ogre::InstancedGeometry::SubMeshLodGeometryLink</a></td><td class="indexvalue">Saved link between <a class="el" href="classOgre_1_1SubMesh.html" title="Defines a part of a complete mesh.">SubMesh</a> at a LOD and vertex/index data May point to original or optimised geometry </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1SubRenderState.html">Ogre::RTShader::SubRenderState</a></td><td class="indexvalue">This class is the base interface of sub part from a shader based rendering pipeline </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1SubRenderStateAccessor.html">Ogre::RTShader::SubRenderStateAccessor</a></td><td class="indexvalue">This class uses as accessor from a template <a class="el" href="classOgre_1_1RTShader_1_1SubRenderState.html" title="This class is the base interface of sub part from a shader based rendering pipeline.">SubRenderState</a> to all of its instances that created based on it </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1SubRenderStateFactory.html">Ogre::RTShader::SubRenderStateFactory</a></td><td class="indexvalue">Abstract factory interface for creating <a class="el" href="classOgre_1_1RTShader_1_1SubRenderState.html" title="This class is the base interface of sub part from a shader based rendering pipeline.">SubRenderState</a> implementation instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TagPoint.html">Ogre::TagPoint</a></td><td class="indexvalue">A tagged point on a skeleton, which can be used to attach entities to on specific other entities </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TangentSpaceCalc.html">Ogre::TangentSpaceCalc</a></td><td class="indexvalue">Class for calculating a tangent space basis </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositorInstance_1_1TargetOperation.html">Ogre::CompositorInstance::TargetOperation</a></td><td class="indexvalue">Operation setup for a <a class="el" href="classOgre_1_1RenderTarget.html" title="A &#39;canvas&#39; which can receive the results of a rendering operation.">RenderTarget</a> (collected) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1TargetRenderState.html">Ogre::RTShader::TargetRenderState</a></td><td class="indexvalue">This is the target render state </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Technique.html">Ogre::Technique</a></td><td class="indexvalue">Class representing an approach to rendering this particular <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TechniqueTranslator.html">Ogre::TechniqueTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TempBlendedBufferInfo.html">Ogre::TempBlendedBufferInfo</a></td><td class="indexvalue">Structure for recording the use of temporary blend buffers </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ManualObject_1_1TempVertex.html">Ogre::ManualObject::TempVertex</a></td><td class="indexvalue">Temporary vertex structure </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Terrain.html">Ogre::Terrain</a></td><td class="indexvalue">The main containing class for a chunk of terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainGlobalOptions.html">Ogre::TerrainGlobalOptions</a></td><td class="indexvalue">Options class which just stores default options for the terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainGroup.html">Ogre::TerrainGroup</a></td><td class="indexvalue">Helper class to assist you in managing multiple terrain instances that are connected to each other </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainLayerBlendMap.html">Ogre::TerrainLayerBlendMap</a></td><td class="indexvalue">Class exposing an interface to a blend map for a given layer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainLayerDeclaration.html">Ogre::TerrainLayerDeclaration</a></td><td class="indexvalue">The definition of the information each layer will contain in this terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainLayerSampler.html">Ogre::TerrainLayerSampler</a></td><td class="indexvalue">Description of a sampler that will be used with each layer </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainLayerSamplerElement.html">Ogre::TerrainLayerSamplerElement</a></td><td class="indexvalue">Information about one element of a sampler / texture within a layer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGenerator.html">Ogre::TerrainMaterialGenerator</a></td><td class="indexvalue">Class that provides functionality to generate materials for use with a terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainMaterialGeneratorA.html">Ogre::TerrainMaterialGeneratorA</a></td><td class="indexvalue">A <a class="el" href="classOgre_1_1TerrainMaterialGenerator.html" title="Class that provides functionality to generate materials for use with a terrain.">TerrainMaterialGenerator</a> which can cope with normal mapped, specular mapped terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainPagedWorldSection.html">Ogre::TerrainPagedWorldSection</a></td><td class="indexvalue">A world section which includes paged terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainPaging.html">Ogre::TerrainPaging</a></td><td class="indexvalue">This class is the 'core' class for paging terrain, that will integrate with the larger paging system and provide the appropriate utility classes required </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TerrainQuadTreeNode.html">Ogre::TerrainQuadTreeNode</a></td><td class="indexvalue">A node in a quad tree used to store a patch of terrain </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainGroup_1_1TerrainSlot.html">Ogre::TerrainGroup::TerrainSlot</a></td><td class="indexvalue">Slot for a terrain instance, together with its definition </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainGroup_1_1TerrainSlotDefinition.html">Ogre::TerrainGroup::TerrainSlotDefinition</a></td><td class="indexvalue">Definition of how to populate a 'slot' in the terrain group </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TexCoordModifierControllerValue.html">Ogre::TexCoordModifierControllerValue</a></td><td class="indexvalue">Predefined controller value for getting / setting a texture coordinate modifications (scales and translates) </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElement.html">Ogre::TextAreaOverlayElement</a></td><td class="indexvalue">This class implements an overlay element which contains simple unformatted text </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextAreaOverlayElementFactory.html">Ogre::TextAreaOverlayElementFactory</a></td><td class="indexvalue">Factory for creating <a class="el" href="classOgre_1_1TextAreaOverlayElement.html" title="This class implements an overlay element which contains simple unformatted text.">TextAreaOverlayElement</a> instances </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Texture.html">Ogre::Texture</a></td><td class="indexvalue">Abstract class representing a <a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> resource </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1CompositorManager_1_1TextureDef.html">Ogre::CompositorManager::TextureDef</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CompositionTechnique_1_1TextureDefinition.html">Ogre::CompositionTechnique::TextureDefinition</a></td><td class="indexvalue">Local texture definition </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1CompositorManager_1_1TextureDefLess.html">Ogre::CompositorManager::TextureDefLess</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TextureUnitState_1_1TextureEffect.html">Ogre::TextureUnitState::TextureEffect</a></td><td class="indexvalue">Internal structure defining a texture effect </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextureFrameControllerValue.html">Ogre::TextureFrameControllerValue</a></td><td class="indexvalue">Predefined controller value for getting / setting the frame number of a texture layer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextureManager.html">Ogre::TextureManager</a></td><td class="indexvalue">Class for loading &amp; managing textures </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TexturePtr.html">Ogre::TexturePtr</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to allow <a class="el" href="classOgre_1_1SharedPtr.html" title="Reference-counted shared pointer, used for objects where implicit destruction is required.">SharedPtr</a> to be assigned to <a class="el" href="classOgre_1_1TexturePtr.html" title="Specialisation of SharedPtr to allow SharedPtr to be assigned to TexturePtr.">TexturePtr</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D9Texture_1_1TextureResources.html">Ogre::D3D9Texture::TextureResources</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextureSourceTranslator.html">Ogre::TextureSourceTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextureUnitState.html">Ogre::TextureUnitState</a></td><td class="indexvalue">Class representing the state of a single texture unit during a <a class="el" href="classOgre_1_1Pass.html" title="Class defining a single pass of a Technique (of a Material), i.e.">Pass</a> of a <a class="el" href="classOgre_1_1Technique.html" title="Class representing an approach to rendering this particular Material.">Technique</a>, of a <a class="el" href="classOgre_1_1Material.html" title="Class encapsulates rendering properties of an object.">Material</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TextureUnitTranslator.html">Ogre::TextureUnitTranslator</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1D3D11Device_1_1ThreadInfo.html">Ogre::D3D11Device::ThreadInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TimeIndex.html">Ogre::TimeIndex</a></td><td class="indexvalue">Time index object used to search keyframe at the given position </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Timer.html">Ogre::Timer</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Timer.html" title="Timer class.">Timer</a> class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1CPreprocessor_1_1Token.html">Ogre::CPreprocessor::Token</a></td><td class="indexvalue">A input token </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1TransformKeyFrame.html">Ogre::TransformKeyFrame</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1KeyFrame.html" title="A key frame in an animation sequence defined by an AnimationTrack.">KeyFrame</a> which stores a full transform </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TRect.html">Ogre::TRect&lt; T &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeData_1_1Triangle.html">Ogre::EdgeData::Triangle</a></td><td class="indexvalue">Basic triangle structure </td></tr>
  <tr><td class="indexkey"><a class="el" href="unionOgre_1_1SmallVectorBase_1_1U.html">Ogre::SmallVectorBase::U</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UnifiedHighLevelGpuProgram.html">Ogre::UnifiedHighLevelGpuProgram</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1HighLevelGpuProgram.html" title="Abstract base class representing a high-level program (a vertex or fragment program).">HighLevelGpuProgram</a> which just delegates its implementation to one other high level program, allowing a single program definition to represent one supported program from a number of options </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UnifiedHighLevelGpuProgramFactory.html">Ogre::UnifiedHighLevelGpuProgramFactory</a></td><td class="indexvalue">Factory class for Unified programs </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RTShader_1_1UniformParameter.html">Ogre::RTShader::UniformParameter</a></td><td class="indexvalue">Uniform parameter class </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UnimplementedException.html">Ogre::UnimplementedException</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1UserObjectBindings.html">Ogre::UserObjectBindings</a></td><td class="indexvalue">Class that provide convenient interface to establish a linkage between custom user application objects and <a class="el" href="namespaceOgre.html">Ogre</a> core classes </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TextureUnitState_1_1UVWAddressingMode.html">Ogre::TextureUnitState::UVWAddressingMode</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Texture.html" title="Abstract class representing a Texture resource.">Texture</a> addressing mode for each texture coordinate </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1RenderQueue_1_1RenderQueueGroupMap_1_1value__type.html">Ogre::RenderQueue::RenderQueueGroupMap::value_type</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VariableAccessAbstractNode.html">Ogre::VariableAccessAbstractNode</a></td><td class="indexvalue">This abstract node represents a variable assignment </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1vector.html">Ogre::vector&lt; T, A &gt;</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Vector2.html">Ogre::Vector2</a></td><td class="indexvalue">Standard 2-dimensional vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Vector3.html">Ogre::Vector3</a></td><td class="indexvalue">Standard 3-dimensional vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Vector4.html">Ogre::Vector4</a></td><td class="indexvalue">4-dimensional homogeneous vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VectorIterator.html">Ogre::VectorIterator&lt; T &gt;</a></td><td class="indexvalue">Concrete <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for nonconst access to the underlying container </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VectorIteratorWrapper.html">Ogre::VectorIteratorWrapper&lt; T, IteratorType &gt;</a></td><td class="indexvalue">Prepiared <a class="el" href="classOgre_1_1IteratorWrapper.html" title="Basefunctionality for IteratorWrappers.">IteratorWrapper</a> for container like std::vector </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1EdgeListBuilder_1_1vectorLess.html">Ogre::EdgeListBuilder::vectorLess</a></td><td class="indexvalue">Comparator for unique vertex list </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1VectorRange.html">Ogre::VectorRange&lt; T &gt;</a></td><td class="indexvalue">Predefined type </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexAnimationTrack.html">Ogre::VertexAnimationTrack</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1AnimationTrack.html" title="A &#39;track&#39; in an animation sequence, i.e.">AnimationTrack</a> for dealing with changing vertex position information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1VertexBoneAssignment__s.html">Ogre::VertexBoneAssignment_s</a></td><td class="indexvalue">Records the assignment of a single vertex to a single bone with the corresponding weight </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexBufferBinding.html">Ogre::VertexBufferBinding</a></td><td class="indexvalue">Records the state of all the vertex buffer bindings required to provide a vertex declaration with the input data it needs for the vertex elements </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1HardwareBufferManagerBase_1_1VertexBufferLicense.html">Ogre::HardwareBufferManagerBase::VertexBufferLicense</a></td><td class="indexvalue">Struct holding details of a license to use a temporary shared buffer </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexCacheProfiler.html">Ogre::VertexCacheProfiler</a></td><td class="indexvalue">Vertex cache profiler </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexData.html">Ogre::VertexData</a></td><td class="indexvalue">Summary class collecting together vertex source information </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TerrainQuadTreeNode_1_1VertexDataRecord.html">Ogre::TerrainQuadTreeNode::VertexDataRecord</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexDeclaration.html">Ogre::VertexDeclaration</a></td><td class="indexvalue">This class declares the format of a set of vertex inputs, which can be issued to the rendering API through a <a class="el" href="classOgre_1_1RenderOperation.html" title="&#39;New&#39; rendering operation using vertex buffers.">RenderOperation</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexElement.html">Ogre::VertexElement</a></td><td class="indexvalue">This class declares the usage of a single vertex buffer as a component of a complete <a class="el" href="classOgre_1_1VertexDeclaration.html" title="This class declares the format of a set of vertex inputs, which can be issued to the rendering API th...">VertexDeclaration</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1TangentSpaceCalc_1_1VertexInfo.html">Ogre::TangentSpaceCalc::VertexInfo</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexMorphKeyFrame.html">Ogre::VertexMorphKeyFrame</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1KeyFrame.html" title="A key frame in an animation sequence defined by an AnimationTrack.">KeyFrame</a> which stores absolute vertex positions for a complete buffer, designed to be interpolated with other keys in the same track </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1VertexPoseKeyFrame.html">Ogre::VertexPoseKeyFrame</a></td><td class="indexvalue">Specialised <a class="el" href="classOgre_1_1KeyFrame.html" title="A key frame in an animation sequence defined by an AnimationTrack.">KeyFrame</a> which references a Mesh::Pose at a certain influence level, which stores offsets for a subset of the vertices in a buffer to provide a blendable pose </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1ViewPoint.html">Ogre::ViewPoint</a></td><td class="indexvalue">Structure for holding a position &amp; orientation pair </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Viewport.html">Ogre::Viewport</a></td><td class="indexvalue">An abstraction of a viewport, i.e </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1VisibleObjectsBoundsInfo.html">Ogre::VisibleObjectsBoundsInfo</a></td><td class="indexvalue">Structure collecting together information about the visible objects that have been discovered in a scene </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Renderable_1_1Visitor.html">Ogre::Renderable::Visitor</a></td><td class="indexvalue"><a class="el" href="classOgre_1_1Renderable_1_1Visitor.html" title="Visitor object that can be used to iterate over a collection of Renderable instances abstractly...">Visitor</a> object that can be used to iterate over a collection of <a class="el" href="classOgre_1_1Renderable.html" title="Abstract class defining the interface all renderable objects must implement.">Renderable</a> instances abstractly </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WaveformControllerFunction.html">Ogre::WaveformControllerFunction</a></td><td class="indexvalue">Predefined controller function based on a waveform </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32Context.html">Ogre::Win32Context</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32EGLContext.html">Ogre::Win32EGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32EGLPBuffer.html">Ogre::Win32EGLPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32EGLSupport.html">Ogre::Win32EGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32EGLWindow.html">Ogre::Win32EGLWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32GLSupport.html">Ogre::Win32GLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32PBuffer.html">Ogre::Win32PBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1Win32Window.html">Ogre::Win32Window</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WindowEventListener.html">Ogre::WindowEventListener</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WindowEventUtilities.html">Ogre::WindowEventUtilities</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WireBoundingBox.html">Ogre::WireBoundingBox</a></td><td class="indexvalue">Allows the rendering of a wireframe bounding box </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1WorkQueue.html">Ogre::WorkQueue</a></td><td class="indexvalue">Interface to a general purpose request / response style background work queue </td></tr>
  <tr><td class="indexkey"><a class="el" href="structOgre_1_1SceneQuery_1_1WorldFragment.html">Ogre::SceneQuery::WorldFragment</a></td><td class="indexvalue">Represents part of the world geometry that is a result of a <a class="el" href="classOgre_1_1SceneQuery.html" title="A class for performing queries on a scene.">SceneQuery</a> </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1X11EGLContext.html">Ogre::X11EGLContext</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1X11EGLPBuffer.html">Ogre::X11EGLPBuffer</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1X11EGLSupport.html">Ogre::X11EGLSupport</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1X11EGLWindow.html">Ogre::X11EGLWindow</a></td><td class="indexvalue"></td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ZipArchive.html">Ogre::ZipArchive</a></td><td class="indexvalue">Specialisation of the <a class="el" href="classOgre_1_1Archive.html" title="Archive-handling class.">Archive</a> class to allow reading of files from a zip format source archive </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ZipArchiveFactory.html">Ogre::ZipArchiveFactory</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1ArchiveFactory.html" title="Abstract factory class, archive codec plugins can register concrete subclasses of this...">ArchiveFactory</a> for Zip files </td></tr>
  <tr><td class="indexkey"><a class="el" href="classOgre_1_1ZipDataStream.html">Ogre::ZipDataStream</a></td><td class="indexvalue">Specialisation of <a class="el" href="classOgre_1_1DataStream.html" title="General purpose class used for encapsulating the reading and writing of data.">DataStream</a> to handle streaming data from zip archives </td></tr>
</table>
</div><!-- contents -->
<hr>
<p>
Copyright &copy; 2012 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Sep 2 2012 07:28:07
</p>
</body>
</html>
