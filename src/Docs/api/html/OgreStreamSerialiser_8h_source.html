<html>
<head>
<title>OgreStreamSerialiser.h Source File - OGRE Documentation</title> <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"> 
<link type="text/css" rel="stylesheet" href="doxygen.css">
<link type="text/css" rel="stylesheet" href="tabs.css">
</head>

<body>
<!-- Generated by Doxygen 1.7.6.1 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="modules.html"><span>Modules</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li><a href="annotated.html"><span>Classes</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li><a href="dirs.html"><span>Directories</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>File&#160;Members</span></a></li>
    </ul>
  </div>
  <div id="nav-path" class="navpath">
    <ul>
      <li class="navelem"><a class="el" href="dir_8388db04747d7625d426abbcac0905dd.html">OgreMain</a>      </li>
      <li class="navelem"><a class="el" href="dir_697e021d2615ffc0898007e3a5fb29f4.html">include</a>      </li>
    </ul>
  </div>
</div>
<div class="header">
  <div class="headertitle">
<div class="title">OgreStreamSerialiser.h</div>  </div>
</div><!--header-->
<div class="contents">
<a href="OgreStreamSerialiser_8h.html">Go to the documentation of this file.</a><div class="fragment"><pre class="fragment"><a name="l00001"></a>00001 <span class="comment">/*</span>
<a name="l00002"></a>00002 <span class="comment">-----------------------------------------------------------------------------</span>
<a name="l00003"></a>00003 <span class="comment">This source file is part of OGRE</span>
<a name="l00004"></a>00004 <span class="comment">(Object-oriented Graphics Rendering Engine)</span>
<a name="l00005"></a>00005 <span class="comment">For the latest info, see http://www.ogre3d.org/</span>
<a name="l00006"></a>00006 <span class="comment"></span>
<a name="l00007"></a>00007 <span class="comment">Copyright (c) 2000-2012 Torus Knot Software Ltd</span>
<a name="l00008"></a>00008 <span class="comment"></span>
<a name="l00009"></a>00009 <span class="comment">Permission is hereby granted, free of charge, to any person obtaining a copy</span>
<a name="l00010"></a>00010 <span class="comment">of this software and associated documentation files (the &quot;Software&quot;), to deal</span>
<a name="l00011"></a>00011 <span class="comment">in the Software without restriction, including without limitation the rights</span>
<a name="l00012"></a>00012 <span class="comment">to use, copy, modify, merge, publish, distribute, sublicense, and/or sell</span>
<a name="l00013"></a>00013 <span class="comment">copies of the Software, and to permit persons to whom the Software is</span>
<a name="l00014"></a>00014 <span class="comment">furnished to do so, subject to the following conditions:</span>
<a name="l00015"></a>00015 <span class="comment"></span>
<a name="l00016"></a>00016 <span class="comment">The above copyright notice and this permission notice shall be included in</span>
<a name="l00017"></a>00017 <span class="comment">all copies or substantial portions of the Software.</span>
<a name="l00018"></a>00018 <span class="comment"></span>
<a name="l00019"></a>00019 <span class="comment">THE SOFTWARE IS PROVIDED &quot;AS IS&quot;, WITHOUT WARRANTY OF ANY KIND, EXPRESS OR</span>
<a name="l00020"></a>00020 <span class="comment">IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,</span>
<a name="l00021"></a>00021 <span class="comment">FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE</span>
<a name="l00022"></a>00022 <span class="comment">AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER</span>
<a name="l00023"></a>00023 <span class="comment">LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,</span>
<a name="l00024"></a>00024 <span class="comment">OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN</span>
<a name="l00025"></a>00025 <span class="comment">THE SOFTWARE.</span>
<a name="l00026"></a>00026 <span class="comment">-----------------------------------------------------------------------------</span>
<a name="l00027"></a>00027 <span class="comment">*/</span>
<a name="l00028"></a>00028 <span class="preprocessor">#ifndef __StreamSerialiser_H__</span>
<a name="l00029"></a>00029 <span class="preprocessor"></span><span class="preprocessor">#define __StreamSerialiser_H__</span>
<a name="l00030"></a>00030 <span class="preprocessor"></span>
<a name="l00031"></a>00031 <span class="preprocessor">#include &quot;<a class="code" href="OgrePrerequisites_8h.html">OgrePrerequisites.h</a>&quot;</span>
<a name="l00032"></a>00032 <span class="preprocessor">#include &quot;<a class="code" href="OgreDataStream_8h.html">OgreDataStream.h</a>&quot;</span>
<a name="l00033"></a>00033 
<a name="l00034"></a>00034 
<a name="l00035"></a>00035 <span class="keyword">namespace </span>Ogre 
<a name="l00036"></a>00036 {
<a name="l00066"></a><a class="code" href="classOgre_1_1StreamSerialiser.html">00066</a>     <span class="keyword">class </span><a class="code" href="OgrePlatform_8h.html#a20566b1253bae200372ed9162489a663">_OgreExport</a> <a class="code" href="classOgre_1_1StreamSerialiser.html" title="Utility class providing helper methods for reading / writing structured data held in a DataStream...">StreamSerialiser</a> : <span class="keyword">public</span> <a class="code" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">StreamAlloc</a>
<a name="l00067"></a>00067     {
<a name="l00068"></a>00068     <span class="keyword">public</span>:
<a name="l00070"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0">00070</a>         <span class="keyword">enum</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0" title="The endianness of files.">Endian</a>
<a name="l00071"></a>00071         {
<a name="l00073"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c">00073</a>             <a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0a921fa6c4bf1316b54e0877ad1e983c9c" title="Automatically determine endianness.">ENDIAN_AUTO</a>,
<a name="l00075"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0afa17cf3b68b6464762f03423afc83d6e">00075</a>             <a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0afa17cf3b68b6464762f03423afc83d6e" title="Use big endian (0x1000 is serialised as 0x10 0x00)">ENDIAN_BIG</a>,
<a name="l00077"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0a344ebede556d120f89fbfd35b544a0fb">00077</a>             ENDIAN_LITTLE
<a name="l00078"></a>00078         };
<a name="l00079"></a>00079 
<a name="l00081"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91">00081</a>         <span class="keyword">enum</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91" title="The storage format of Real values.">RealStorageFormat</a>
<a name="l00082"></a>00082         {
<a name="l00084"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837">00084</a>             <a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91ae3bcbc915c3187091bf95f1e7426a837" title="Real is stored as float, reducing precision if you&#39;re using OGRE_DOUBLE_PRECISION.">REAL_FLOAT</a>,
<a name="l00086"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91a2b594a33ac97bd7a0cc2d9047e2b1912">00086</a>             REAL_DOUBLE
<a name="l00087"></a>00087         };
<a name="l00088"></a>00088 
<a name="l00089"></a>00089 
<a name="l00091"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html">00091</a>         <span class="keyword">struct </span><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html" title="Definition of a chunk of data in a file.">Chunk</a> : <span class="keyword">public</span> <a class="code" href="classOgre_1_1AllocatedObject.html" title="Superclass for all objects that wish to use custom memory allocators when their new / delete operator...">StreamAlloc</a>
<a name="l00092"></a>00092         {
<a name="l00094"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a5ff82e35d66f9ae31a67612359f186f6">00094</a>             <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a5ff82e35d66f9ae31a67612359f186f6" title="Identifier of the chunk (for example from makeIdentifier) (stored)">id</a>;
<a name="l00096"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a5b7d48d0df881bcc1b0b3035c355fbca">00096</a>             <a class="code" href="namespaceOgre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a5b7d48d0df881bcc1b0b3035c355fbca" title="Version of the chunk (stored)">version</a>;
<a name="l00098"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#aee59026e7658bc15408b2f92ee1140cb">00098</a>             <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#aee59026e7658bc15408b2f92ee1140cb" title="Length of the chunk data in bytes, excluding the header of this chunk (stored)">length</a>;
<a name="l00100"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a53db274d39b9f3d328cdefb67bbc0f00">00100</a>             <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#a53db274d39b9f3d328cdefb67bbc0f00" title="Location of the chunk (header) in bytes from the start of a stream (derived)">offset</a>;
<a name="l00101"></a>00101 
<a name="l00102"></a><a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#aa96c50461348d92b92ff435612c0f5a7">00102</a>             <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html#aa96c50461348d92b92ff435612c0f5a7">Chunk</a>() : id(0), version(1), length(0), offset(0) {}
<a name="l00103"></a>00103         };
<a name="l00104"></a>00104 
<a name="l00122"></a>00122         <a class="code" href="classOgre_1_1StreamSerialiser.html" title="Utility class providing helper methods for reading / writing structured data held in a DataStream...">StreamSerialiser</a>(<span class="keyword">const</span> <a class="code" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a>&amp; stream, Endian endianMode = ENDIAN_AUTO, 
<a name="l00123"></a>00123             <span class="keywordtype">bool</span> autoHeader = <span class="keyword">true</span>, 
<a name="l00124"></a>00124 #<span class="keywordflow">if</span> OGRE_DOUBLE_PRECISION
<a name="l00125"></a>00125             RealStorageFormat realFormat = REAL_DOUBLE
<a name="l00126"></a>00126 #<span class="keywordflow">else</span>
<a name="l00127"></a>00127             RealStorageFormat realFormat = REAL_FLOAT
<a name="l00128"></a>00128 #endif
<a name="l00129"></a>00129             );
<a name="l00130"></a>00130         <span class="keyword">virtual</span> ~<a class="code" href="classOgre_1_1StreamSerialiser.html" title="Utility class providing helper methods for reading / writing structured data held in a DataStream...">StreamSerialiser</a>();
<a name="l00131"></a>00131 
<a name="l00137"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a7cd041da1de973be0a92ca775be612f0">00137</a>         <span class="keyword">virtual</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0" title="The endianness of files.">Endian</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a7cd041da1de973be0a92ca775be612f0" title="Get the endian mode.">getEndian</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mEndian; }
<a name="l00138"></a>00138 
<a name="l00145"></a>00145         <span class="keyword">static</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> makeIdentifier(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; code);
<a name="l00146"></a>00146 
<a name="l00153"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#af5c1b38b9f485dd541c5e9aa9ea7b570">00153</a>         <span class="keywordtype">size_t</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#af5c1b38b9f485dd541c5e9aa9ea7b570" title="Report the current depth of the chunk nesting, whether reading or writing.">getCurrentChunkDepth</a>()<span class="keyword"> const </span>{ <span class="keywordflow">return</span> mChunkStack.size(); }
<a name="l00154"></a>00154 
<a name="l00159"></a>00159         <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> getCurrentChunkID() <span class="keyword">const</span>;
<a name="l00160"></a>00160 
<a name="l00168"></a>00168         <span class="keywordtype">size_t</span> getOffsetFromChunkStart() <span class="keyword">const</span>;
<a name="l00169"></a>00169 
<a name="l00181"></a>00181         <span class="keyword">virtual</span> <span class="keyword">const</span> Chunk* readChunkBegin();
<a name="l00182"></a>00182 
<a name="l00195"></a>00195         <span class="keyword">virtual</span> <span class="keyword">const</span> Chunk* readChunkBegin(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>, <a class="code" href="namespaceOgre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> maxVersion, <span class="keyword">const</span> <a class="code" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>&amp; msg = <a class="code" href="classOgre_1_1StringUtil.html#ad2ead745c8c6f4f7056270e22f29e4da" title="Constant blank string, useful for returning by ref where local does not exist.">StringUtil::BLANK</a>);
<a name="l00196"></a>00196 
<a name="l00206"></a>00206         <span class="keyword">virtual</span> <span class="keywordtype">void</span> undoReadChunk(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>);
<a name="l00207"></a>00207 
<a name="l00209"></a>00209         <span class="keyword">virtual</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> peekNextChunkID(); 
<a name="l00210"></a>00210 
<a name="l00219"></a>00219         <span class="keyword">virtual</span> <span class="keywordtype">void</span> readChunkEnd(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>);
<a name="l00220"></a>00220 
<a name="l00224"></a>00224         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> isEndOfChunk(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>);
<a name="l00225"></a>00225 
<a name="l00227"></a>00227         <span class="keyword">virtual</span> <span class="keywordtype">bool</span> eof() <span class="keyword">const</span>;
<a name="l00228"></a>00228 
<a name="l00230"></a>00230         <span class="keyword">virtual</span> <span class="keyword">const</span> Chunk* getCurrentChunk() <span class="keyword">const</span>;
<a name="l00231"></a>00231 
<a name="l00246"></a>00246         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeChunkBegin(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>, <a class="code" href="namespaceOgre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> version = 1);
<a name="l00251"></a>00251         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeChunkEnd(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>);
<a name="l00252"></a>00252 
<a name="l00259"></a>00259         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeData(<span class="keyword">const</span> <span class="keywordtype">void</span>* buf, <span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> count);
<a name="l00260"></a>00260 
<a name="l00262"></a>00262         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00263"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a2aae82219abe1e37ea5f1c1adf8bdd1c">00263</a>         <span class="keywordtype">void</span> write(<span class="keyword">const</span> T* pT, <span class="keywordtype">size_t</span> count = 1)
<a name="l00264"></a>00264         {
<a name="l00265"></a>00265             writeData(pT, <span class="keyword">sizeof</span>(T), count);
<a name="l00266"></a>00266         }
<a name="l00267"></a>00267 
<a name="l00268"></a>00268         <span class="comment">// Special-case Real since we need to deal with single/double precision</span>
<a name="l00269"></a>00269         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d" title="Software floating point type.">Real</a>* val, <span class="keywordtype">size_t</span> count = 1);
<a name="l00270"></a>00270 
<a name="l00271"></a>00271         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector2.html" title="Standard 2-dimensional vector.">Vector2</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00272"></a>00272         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector3.html" title="Standard 3-dimensional vector.">Vector3</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00273"></a>00273         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Vector4.html" title="4-dimensional homogeneous vector.">Vector4</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00274"></a>00274         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a>* q, <span class="keywordtype">size_t</span> count = 1);
<a name="l00275"></a>00275         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Matrix3.html" title="A 3x3 matrix which can represent rotations around axes.">Matrix3</a>* m, <span class="keywordtype">size_t</span> count = 1);
<a name="l00276"></a>00276         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Matrix4.html" title="Class encapsulating a standard 4x4 homogeneous matrix.">Matrix4</a>* m, <span class="keywordtype">size_t</span> count = 1);
<a name="l00277"></a>00277         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>* <span class="keywordtype">string</span>);
<a name="l00278"></a>00278         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1AxisAlignedBox.html" title="A 3D box aligned with the x/y/z axes.">AxisAlignedBox</a>* aabb, <span class="keywordtype">size_t</span> count = 1);
<a name="l00279"></a>00279         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a>* sphere, <span class="keywordtype">size_t</span> count = 1);
<a name="l00280"></a>00280         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Plane.html" title="Defines a plane in 3D space.">Plane</a>* plane, <span class="keywordtype">size_t</span> count = 1);
<a name="l00281"></a>00281         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Ray.html" title="Representation of a ray in space, i.e.">Ray</a>* ray, <span class="keywordtype">size_t</span> count = 1);
<a name="l00282"></a>00282         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Radian.html" title="Wrapper class which indicates a given angle value is in Radians.">Radian</a>* angle, <span class="keywordtype">size_t</span> count = 1);
<a name="l00283"></a>00283         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <a class="code" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>* node, <span class="keywordtype">size_t</span> count = 1);
<a name="l00284"></a>00284         <span class="keyword">virtual</span> <span class="keywordtype">void</span> write(<span class="keyword">const</span> <span class="keywordtype">bool</span>* <span class="keywordtype">boolean</span>, <span class="keywordtype">size_t</span> count = 1);
<a name="l00285"></a>00285 
<a name="l00286"></a>00286 
<a name="l00293"></a>00293         <span class="keyword">virtual</span> <span class="keywordtype">void</span> readData(<span class="keywordtype">void</span>* buf, <span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> count);
<a name="l00294"></a>00294 
<a name="l00296"></a>00296         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T&gt;
<a name="l00297"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a72a8e8540b453b8428992c0c6c599995">00297</a>         <span class="keywordtype">void</span> read(T* pT, <span class="keywordtype">size_t</span> count = 1)
<a name="l00298"></a>00298         {
<a name="l00299"></a>00299             readData(pT, <span class="keyword">sizeof</span>(T), count);
<a name="l00300"></a>00300         }
<a name="l00301"></a>00301 
<a name="l00302"></a>00302         <span class="comment">// Special case Real, single/double-precision issues</span>
<a name="l00303"></a>00303         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="namespaceOgre.html#aa3a7b6dfb905e6572d62f0dfa3d4274d" title="Software floating point type.">Real</a>* val, <span class="keywordtype">size_t</span> count = 1);
<a name="l00304"></a>00304 
<a name="l00306"></a>00306         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Vector2.html" title="Standard 2-dimensional vector.">Vector2</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00307"></a>00307         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Vector3.html" title="Standard 3-dimensional vector.">Vector3</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00308"></a>00308         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Vector4.html" title="4-dimensional homogeneous vector.">Vector4</a>* vec, <span class="keywordtype">size_t</span> count = 1);
<a name="l00309"></a>00309         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Quaternion.html" title="Implementation of a Quaternion, i.e.">Quaternion</a>* q, <span class="keywordtype">size_t</span> count = 1);
<a name="l00310"></a>00310         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Matrix3.html" title="A 3x3 matrix which can represent rotations around axes.">Matrix3</a>* m, <span class="keywordtype">size_t</span> count = 1);
<a name="l00311"></a>00311         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Matrix4.html" title="Class encapsulating a standard 4x4 homogeneous matrix.">Matrix4</a>* m, <span class="keywordtype">size_t</span> count = 1);
<a name="l00312"></a>00312         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="namespaceOgre.html#af73bbdc8bed8a3e6fcd56bb8fa188c45">String</a>* <span class="keywordtype">string</span>);
<a name="l00313"></a>00313         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1AxisAlignedBox.html" title="A 3D box aligned with the x/y/z axes.">AxisAlignedBox</a>* aabb, <span class="keywordtype">size_t</span> count = 1);
<a name="l00314"></a>00314         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Sphere.html" title="A sphere primitive, mostly used for bounds checking.">Sphere</a>* sphere, <span class="keywordtype">size_t</span> count = 1);
<a name="l00315"></a>00315         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Plane.html" title="Defines a plane in 3D space.">Plane</a>* plane, <span class="keywordtype">size_t</span> count = 1);
<a name="l00316"></a>00316         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Ray.html" title="Representation of a ray in space, i.e.">Ray</a>* ray, <span class="keywordtype">size_t</span> count = 1);
<a name="l00317"></a>00317         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Radian.html" title="Wrapper class which indicates a given angle value is in Radians.">Radian</a>* angle, <span class="keywordtype">size_t</span> count = 1);
<a name="l00318"></a>00318         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<a class="code" href="classOgre_1_1Node.html" title="Class representing a general-purpose node an articulated scene graph.">Node</a>* node, <span class="keywordtype">size_t</span> count = 1);
<a name="l00319"></a>00319         <span class="keyword">virtual</span> <span class="keywordtype">void</span> read(<span class="keywordtype">bool</span>* val, <span class="keywordtype">size_t</span> count = 1);
<a name="l00320"></a>00320 
<a name="l00321"></a>00321     <span class="keyword">protected</span>:
<a name="l00322"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#aa66d607581455552e7cc8e0ab835cc59">00322</a>         <a class="code" href="classOgre_1_1SharedPtr.html">DataStreamPtr</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#aa66d607581455552e7cc8e0ab835cc59">mStream</a>;
<a name="l00323"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a1afd29f84fe8344d0f7df4a0bcd427a6">00323</a>         <a class="code" href="classOgre_1_1StreamSerialiser.html#a072077ff56678e964608a7451db7c3f0" title="The endianness of files.">Endian</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a1afd29f84fe8344d0f7df4a0bcd427a6">mEndian</a>;
<a name="l00324"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a4b1ace79e9f4d9a1b63a2ce4212e4dd8">00324</a>         <span class="keywordtype">bool</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#a4b1ace79e9f4d9a1b63a2ce4212e4dd8">mFlipEndian</a>;
<a name="l00325"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#ad1f0a83979a77f2b9697878f0b2ca1b5">00325</a>         <span class="keywordtype">bool</span> <a class="code" href="classOgre_1_1StreamSerialiser.html#ad1f0a83979a77f2b9697878f0b2ca1b5">mReadWriteHeader</a>;
<a name="l00326"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a21c3c9f215ea3b5c279fd2fdee0941ca">00326</a>         <a class="code" href="classOgre_1_1StreamSerialiser.html#a6cf4285399b89b088f2f297dda10fc91" title="The storage format of Real values.">RealStorageFormat</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a21c3c9f215ea3b5c279fd2fdee0941ca">mRealFormat</a>;
<a name="l00327"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a49a41720d6ae13bafab2fb3c1e2b429a">00327</a>         <span class="keyword">typedef</span> <a class="code" href="structOgre_1_1deque.html">deque&lt;Chunk*&gt;::type</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a49a41720d6ae13bafab2fb3c1e2b429a">ChunkStack</a>;
<a name="l00329"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a1f7b65be90a60d36ede21ddbca4cba4e">00329</a>         <a class="code" href="classOgre_1_1StreamSerialiser.html#a49a41720d6ae13bafab2fb3c1e2b429a">ChunkStack</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a1f7b65be90a60d36ede21ddbca4cba4e" title="Current list of open chunks.">mChunkStack</a>;
<a name="l00330"></a>00330 
<a name="l00331"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a3a0ecfedc4bc930bce30443f3ba4f74b">00331</a>         <span class="keyword">static</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a3a0ecfedc4bc930bce30443f3ba4f74b">HEADER_ID</a>;
<a name="l00332"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a719bc5b2dbd34177bc90955572564cde">00332</a>         <span class="keyword">static</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a719bc5b2dbd34177bc90955572564cde">REVERSE_HEADER_ID</a>;
<a name="l00333"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a237486ba1b145cfe570c51cedb54ee3a">00333</a>         <span class="keyword">static</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <a class="code" href="classOgre_1_1StreamSerialiser.html#a237486ba1b145cfe570c51cedb54ee3a">CHUNK_HEADER_SIZE</a>;
<a name="l00334"></a>00334 
<a name="l00335"></a>00335         <span class="keyword">virtual</span> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html" title="Definition of a chunk of data in a file.">Chunk</a>* readChunkImpl();
<a name="l00336"></a>00336         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeChunkImpl(<a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> <span class="keywordtype">id</span>, <a class="code" href="namespaceOgre.html#aa8263b218e7d187ad5ef03a73a6ad7fd">uint16</a> version);
<a name="l00337"></a>00337         <span class="keyword">virtual</span> <span class="keywordtype">void</span> readHeader();
<a name="l00338"></a>00338         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeHeader();
<a name="l00339"></a>00339         <span class="keyword">virtual</span> <a class="code" href="namespaceOgre.html#adf2a0cf2e77143b5ee1d38a75e289545">uint32</a> calculateChecksum(<a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html" title="Definition of a chunk of data in a file.">Chunk</a>* c);
<a name="l00340"></a>00340         <span class="keyword">virtual</span> <span class="keywordtype">void</span> checkStream(<span class="keywordtype">bool</span> failOnEof = <span class="keyword">false</span>, 
<a name="l00341"></a>00341             <span class="keywordtype">bool</span> validateReadable = <span class="keyword">false</span>, <span class="keywordtype">bool</span> validateWriteable = <span class="keyword">false</span>) <span class="keyword">const</span>;
<a name="l00342"></a>00342 
<a name="l00343"></a>00343         <span class="keyword">virtual</span> <span class="keywordtype">void</span> flipEndian(<span class="keywordtype">void</span> * pData, <span class="keywordtype">size_t</span> size, <span class="keywordtype">size_t</span> count);
<a name="l00344"></a>00344         <span class="keyword">virtual</span> <span class="keywordtype">void</span> flipEndian(<span class="keywordtype">void</span> * pData, <span class="keywordtype">size_t</span> size);
<a name="l00345"></a>00345         <span class="keyword">virtual</span> <span class="keywordtype">void</span> determineEndianness();
<a name="l00346"></a>00346         <span class="keyword">virtual</span> <a class="code" href="structOgre_1_1StreamSerialiser_1_1Chunk.html" title="Definition of a chunk of data in a file.">Chunk</a>* popChunk(<a class="code" href="namespaceOgre.html#ab6e842a18caf062ed73a5d3badd0dd4c">uint</a> <span class="keywordtype">id</span>);
<a name="l00347"></a>00347 
<a name="l00348"></a>00348         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeFloatsAsDoubles(<span class="keyword">const</span> <span class="keywordtype">float</span>* val, <span class="keywordtype">size_t</span> count);
<a name="l00349"></a>00349         <span class="keyword">virtual</span> <span class="keywordtype">void</span> writeDoublesAsFloats(<span class="keyword">const</span> <span class="keywordtype">double</span>* val, <span class="keywordtype">size_t</span> count);
<a name="l00350"></a>00350         <span class="keyword">virtual</span> <span class="keywordtype">void</span> readFloatsAsDoubles(<span class="keywordtype">double</span>* val, <span class="keywordtype">size_t</span> count);
<a name="l00351"></a>00351         <span class="keyword">virtual</span> <span class="keywordtype">void</span> readDoublesAsFloats(<span class="keywordtype">float</span>* val, <span class="keywordtype">size_t</span> count);
<a name="l00352"></a>00352         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
<a name="l00353"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#a7dafee8d9dd56a443179c26b2cf1ad6c">00353</a>         <span class="keywordtype">void</span> writeConverted(<span class="keyword">const</span> T* src, U typeToWrite, <span class="keywordtype">size_t</span> count)
<a name="l00354"></a>00354         {
<a name="l00355"></a>00355             U* tmp = <a class="code" href="group__Memory.html#ga3211e4a6a806aa789b38dce2432ef472" title="Allocate a block of memory for a primitive type, and indicate the category of usage.">OGRE_ALLOC_T</a>(U, count, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
<a name="l00356"></a>00356             U* pDst = tmp;
<a name="l00357"></a>00357             <span class="keyword">const</span> T* pSrc = src;
<a name="l00358"></a>00358             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i)
<a name="l00359"></a>00359                 *pDst++ = static_cast&lt;U&gt;(*pSrc++);
<a name="l00360"></a>00360             
<a name="l00361"></a>00361             writeData(tmp, <span class="keyword">sizeof</span>(U), count);
<a name="l00362"></a>00362 
<a name="l00363"></a>00363             <a class="code" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf" title="Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required to be restated to en...">OGRE_FREE</a>(tmp, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
<a name="l00364"></a>00364         }
<a name="l00365"></a>00365         <span class="keyword">template</span> &lt;<span class="keyword">typename</span> T, <span class="keyword">typename</span> U&gt;
<a name="l00366"></a><a class="code" href="classOgre_1_1StreamSerialiser.html#abe33f9186fecab03302d2e75632faf3f">00366</a>         <span class="keywordtype">void</span> readConverted(T* dst, U typeToRead, <span class="keywordtype">size_t</span> count)
<a name="l00367"></a>00367         {
<a name="l00368"></a>00368             U* tmp = <a class="code" href="group__Memory.html#ga3211e4a6a806aa789b38dce2432ef472" title="Allocate a block of memory for a primitive type, and indicate the category of usage.">OGRE_ALLOC_T</a>(U, count, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
<a name="l00369"></a>00369             readData(tmp, <span class="keyword">sizeof</span>(U), count);
<a name="l00370"></a>00370 
<a name="l00371"></a>00371             T* pDst = dst;
<a name="l00372"></a>00372             <span class="keyword">const</span> U* pSrc = tmp;
<a name="l00373"></a>00373             <span class="keywordflow">for</span> (<span class="keywordtype">size_t</span> i = 0; i &lt; count; ++i)
<a name="l00374"></a>00374                 *pDst++ = static_cast&lt;T&gt;(*pSrc++);
<a name="l00375"></a>00375 
<a name="l00376"></a>00376 
<a name="l00377"></a>00377             <a class="code" href="group__Memory.html#gacfd8dc937cf390c7bff05495f0dc10cf" title="Free the memory allocated with OGRE_MALLOC or OGRE_ALLOC_T. Category is required to be restated to en...">OGRE_FREE</a>(tmp, <a class="code" href="group__Memory.html#gga830fab51be174d6f2849857cb1abb36aa8ac29a2852b1b5fe79d1659b16f521cb" title="General purpose.">MEMCATEGORY_GENERAL</a>);
<a name="l00378"></a>00378         }
<a name="l00379"></a>00379 
<a name="l00380"></a>00380     };
<a name="l00383"></a>00383 }
<a name="l00384"></a>00384 
<a name="l00385"></a>00385 <span class="preprocessor">#endif</span>
<a name="l00386"></a>00386 <span class="preprocessor"></span>
</pre></div></div><!-- contents -->
<hr>
<p>
Copyright &copy; 2012 Torus Knot Software Ltd<br />
<!--Creative Commons License--><a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/"><img alt="Creative Commons License" style="border-width:0" src="http://i.creativecommons.org/l/by-sa/3.0/88x31.png" /></a><br />This work is licensed under a <a rel="license" href="http://creativecommons.org/licenses/by-sa/3.0/">Creative Commons Attribution-ShareAlike 3.0 Unported License</a>.<br/>
		<!--/Creative Commons License--><!-- <rdf:RDF xmlns="http://web.resource.org/cc/" xmlns:dc="http://purl.org/dc/elements/1.1/" xmlns:rdf="http://www.w3.org/1999/02/22-rdf-syntax-ns#">
		<Work rdf:about="">
			<license rdf:resource="http://creativecommons.org/licenses/by-sa/2.5/" />
	<dc:type rdf:resource="http://purl.org/dc/dcmitype/Text" />
		</Work>
		<License rdf:about="http://creativecommons.org/licenses/by-sa/2.5/"><permits rdf:resource="http://web.resource.org/cc/Reproduction"/><permits rdf:resource="http://web.resource.org/cc/Distribution"/><requires rdf:resource="http://web.resource.org/cc/Notice"/><requires rdf:resource="http://web.resource.org/cc/Attribution"/><permits rdf:resource="http://web.resource.org/cc/DerivativeWorks"/><requires rdf:resource="http://web.resource.org/cc/ShareAlike"/></License></rdf:RDF> -->

Last modified Sun Sep 2 2012 07:27:24
</p>
</body>
</html>
